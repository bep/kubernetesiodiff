<html>
<body>
<h1>
  Service
</h1>
<p>
  <a href="https://github.com/kubernetes/website/edit/master/content/en/docs/concepts/services-networking/service.md" id="editPageButton" target="_blank">
    Edit This Page
  </a>
</p>
<h1>
  Service
</h1>
<p>
  An abstract way to expose an application running on a set of
  <a class='glossary-tooltip' href='/docs/concepts/workloads/pods/pod-overview/' target='_blank'>
    Pods
    <span class='tooltip-text'>
      The smallest and simplest Kubernetes object. A Pod represents a set of running containers on your cluster.
    </span>
  </a>
  as a network service.
</p>
<p>
  With Kubernetes you don&rsquo;t need to modify your application to use an unfamiliar service discovery mechanism.
  Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods,
  and can load-balance across them.
</p>
<ul id="markdown-toc">
  <li>
    <a href="#motivation">
      Motivation
    </a>
  </li>
  <li>
    <a href="#service-resource">
      Service resources
    </a>
  </li>
  <li>
    <a href="#defining-a-service">
      Defining a Service
    </a>
  </li>
  <li>
    <a href="#virtual-ips-and-service-proxies">
      Virtual IPs and service proxies
    </a>
  </li>
  <li>
    <a href="#multi-port-services">
      Multi-Port Services
    </a>
  </li>
  <li>
    <a href="#choosing-your-own-ip-address">
      Choosing your own IP address
    </a>
  </li>
  <li>
    <a href="#discovering-services">
      Discovering services
    </a>
  </li>
  <li>
    <a href="#headless-services">
      Headless Services
    </a>
  </li>
  <li>
    <a href="#publishing-services-service-types">
      Publishing Services (ServiceTypes)
    </a>
  </li>
  <li>
    <a href="#shortcomings">
      Shortcomings
    </a>
  </li>
  <li>
    <a href="#the-gory-details-of-virtual-ips">
      Virtual IP implementation
    </a>
  </li>
  <li>
    <a href="#api-object">
      API Object
    </a>
  </li>
  <li>
    <a href="#protocol-support">
      Supported protocols
    </a>
  </li>
  <li>
    <a href="#what-s-next">
      What's next
    </a>
  </li>
</ul>
<h2 id="motivation">
  Motivation
</h2>
<p>
  Kubernetes
  <a class='glossary-tooltip' href='/docs/concepts/workloads/pods/pod-overview/' target='_blank'>
    Pods
    <span class='tooltip-text'>
      The smallest and simplest Kubernetes object. A Pod represents a set of running containers on your cluster.
    </span>
  </a>
  are mortal.
  They are born and when they die, they are not resurrected.
  If you use a
  <a class='glossary-tooltip' href='/docs/concepts/workloads/controllers/deployment/' target='_blank'>
    Deployment
    <span class='tooltip-text'>
      An API object that manages a replicated application.
    </span>
  </a>
  to run your app,
  it can create and destroy Pods dynamically.
</p>
<p>
  Each Pod gets its own IP address, however in a Deployment, the set of Pods
  running in one moment in time could be different from
  the set of Pods running that application a moment later.
</p>
<p>
  This leads to a problem: if some set of Pods (call them “backends”) provides
  functionality to other Pods (call them “frontends”) inside your cluster,
  how do the frontends find out and keep track of which IP address to connect
  to, so that the frontend can use the backend part of the workload?
</p>
<p>
  Enter
  <em>
    Services
  </em>
  .
</p>
<h2 id="service-resource">
  Service resources
</h2>
<p>
  In Kubernetes, a Service is an abstraction which defines a logical set of Pods
  and a policy by which to access them (sometimes this pattern is called
  a micro-service). The set of Pods targeted by a Service is usually determined
  by a
  <a class='glossary-tooltip' href='/docs/concepts/overview/working-with-objects/labels/' target='_blank'>
    selector
    <span class='tooltip-text'>
      Allows users to filter a list of resources based on labels.
    </span>
  </a>
  (see
  <a href="#services-without-selectors">
    below
  </a>
  for why you might want a Service
  <em>
    without
  </em>
  a selector).
</p>
<p>
  For example, consider a stateless image-processing backend which is running with
  3 replicas.  Those replicas are fungible&mdash;frontends do not care which backend
  they use.  While the actual Pods that compose the backend set may change, the
  frontend clients should not need to be aware of that, nor should they need to keep
  track of the set of backends themselves.
</p>
<p>
  The Service abstraction enables this decoupling.
</p>
<h3 id="cloud-native-service-discovery">
  Cloud-native service discovery
</h3>
<p>
  If you&rsquo;re able to use Kubernetes APIs for service discovery in your application,
  you can query the
  <a class='glossary-tooltip' href='/docs/reference/generated/kube-apiserver/' target='_blank'>
    API server
    <span class='tooltip-text'>
      Control plane component that serves the Kubernetes API.
    </span>
  </a>
  for Endpoints, that get updated whenever the set of Pods in a Service changes.
</p>
<p>
  For non-native applications, Kubernetes offers ways to place a network port or load
  balancer in between your application and the backend Pods.
</p>
<h2 id="defining-a-service">
  Defining a Service
</h2>
<p>
  A Service in Kubernetes is a REST object, similar to a Pod.  Like all of the
  REST objects, you can
  <code>
    POST
  </code>
  a Service definition to the API server to create
  a new instance.
  The name of a Service object must be a valid
  <a href="/docs/concepts/overview/working-with-objects/names#dns-label-names">
    DNS label name
  </a>
  .
</p>
<p>
  For example, suppose you have a set of Pods that each listen on TCP port 9376
  and carry a label
  <code>
    app=MyApp
  </code>
  :
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#a2f;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">app</span>:<span style="color:#bbb"> </span>MyApp<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">ports</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#a2f;font-weight:bold">protocol</span>:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">port</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">targetPort</span>:<span style="color:#bbb"> </span><span style="color:#666">9376</span></code></pre>
</div>
<p>
  This specification creates a new Service object named “my-service”, which
  targets TCP port 9376 on any Pod with the
  <code>
    app=MyApp
  </code>
  label.
</p>
<p>
  Kubernetes assigns this Service an IP address (sometimes called the &ldquo;cluster IP&rdquo;),
  which is used by the Service proxies
  (see
  <a href="#virtual-ips-and-service-proxies">
    Virtual IPs and service proxies
  </a>
  below).
</p>
<p>
  The controller for the Service selector continuously scans for Pods that
  match its selector, and then POSTs any updates to an Endpoint object
  also named “my-service”.
</p>
<blockquote class="note">
  <div>
    <strong>
      Note:
    </strong>
    A Service can map
    <em>
      any
    </em>
    incoming
    <code>
      port
    </code>
    to a
    <code>
      targetPort
    </code>
    . By default and
    for convenience, the
    <code>
      targetPort
    </code>
    is set to the same value as the
    <code>
      port
    </code>
    field.
  </div>
</blockquote>
<p>
  Port definitions in Pods have names, and you can reference these names in the
  <code>
    targetPort
  </code>
  attribute of a Service. This works even if there is a mixture
  of Pods in the Service using a single configured name, with the same network
  protocol available via different port numbers.
  This offers a lot of flexibility for deploying and evolving your Services.
  For example, you can change the port numbers that Pods expose in the next
  version of your backend software, without breaking clients.
</p>
<p>
  The default protocol for Services is TCP; you can also use any other
  <a href="#protocol-support">
    supported protocol
  </a>
  .
</p>
<p>
  As many Services need to expose more than one port, Kubernetes supports multiple
  port definitions on a Service object.
  Each port definition can have the same
  <code>
    protocol
  </code>
  , or a different one.
</p>
<h3 id="services-without-selectors">
  Services without selectors
</h3>
<p>
  Services most commonly abstract access to Kubernetes Pods, but they can also
  abstract other kinds of backends.
  For example:
</p>
<ul>
  <li>
    You want to have an external database cluster in production, but in your
    test environment you use your own databases.
  </li>
  <li>
    You want to point your Service to a Service in a different
    <a class='glossary-tooltip' href='/docs/concepts/overview/working-with-objects/namespaces' target='_blank'>
      Namespace
      <span class='tooltip-text'>
        An abstraction used by Kubernetes to support multiple virtual clusters on the same physical cluster.
      </span>
    </a>
    or on another cluster.
  </li>
  <li>
    You are migrating a workload to Kubernetes. Whilst evaluating the approach,
    you run only a proportion of your backends in Kubernetes.
  </li>
</ul>
<p>
  In any of these scenarios you can define a Service
  <em>
    without
  </em>
  a Pod selector.
  For example:
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#a2f;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">ports</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#a2f;font-weight:bold">protocol</span>:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">port</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">targetPort</span>:<span style="color:#bbb"> </span><span style="color:#666">9376</span></code></pre>
</div>
<p>
  Because this Service has no selector, the corresponding Endpoint object is
  <em>
    not
  </em>
  created automatically. You can manually map the Service to the network address and port
  where it&rsquo;s running, by adding an Endpoint object manually:
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#a2f;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Endpoints<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">subsets</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#a2f;font-weight:bold">addresses</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#a2f;font-weight:bold">ip</span>:<span style="color:#bbb"> </span><span style="color:#666">192.0.2.42</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">ports</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#a2f;font-weight:bold">port</span>:<span style="color:#bbb"> </span><span style="color:#666">9376</span></code></pre>
</div>
<p>
  The name of the Endpoints object must be a valid
  <a href="/docs/concepts/overview/working-with-objects/names#dns-subdomain-names">
    DNS subdomain name
  </a>
  .
</p>
<blockquote class="note">
  <div>
    <strong>
      Note:
    </strong>
    <p>
      The endpoint IPs
      <em>
        must not
      </em>
      be: loopback (127.0.0.0/8 for IPv4, ::
      <sup>
        1
      </sup>
      &frasl;
      <sub>
        128
      </sub>
      for IPv6), or
      link-local (169.254.0.0/16 and 224.0.0.0/24 for IPv4, fe80::/64 for IPv6).
    </p>
    <p>
      Endpoint IP addresses cannot be the cluster IPs of other Kubernetes Services,
      because
      <a class='glossary-tooltip' href='/docs/reference/command-line-tools-reference/kube-proxy/' target='_blank'>
        kube-proxy
        <span class='tooltip-text'>
          kube-proxy is a network proxy that runs on each node in the cluster.
        </span>
      </a>
      doesn&rsquo;t support virtual IPs
      as a destination.
    </p>
  </div>
</blockquote>
<p>
  Accessing a Service without a selector works the same as if it had a selector.
  In the example above, traffic is routed to the single endpoint defined in
  the YAML:
  <code>
    192.0.2.42:9376
  </code>
  (TCP).
</p>
<p>
  An ExternalName Service is a special case of Service that does not have
  selectors and uses DNS names instead. For more information, see the
  <a href="#externalname">
    ExternalName
  </a>
  section later in this document.
</p>
<h3 id="endpointslices">
  EndpointSlices
</h3>
<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>
    FEATURE STATE:
  </b>
  <code>
    Kubernetes v1.17
  </code>
  <a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all">
    <span class="ui-icon ui-icon-newwin"></span>
    beta
  </a>
  <div id="feature-state-dialog" class="ui-dialog-content" title="beta">
    <p>
      This feature is currently in a
      <em>
        beta
      </em>
      state, meaning:
    </p>
    <ul>
      <li>
        The version names contain beta (e.g. v2beta3).
      </li>
      <li>
        Code is well tested. Enabling the feature is considered safe. Enabled by default.
      </li>
      <li>
        Support for the overall feature will not be dropped, though details may change.
      </li>
      <li>
        The schema and/or semantics of objects may change in incompatible ways in a subsequent beta or stable release. When this happens, we will provide instructions for migrating to the next version. This may require deleting, editing, and re-creating API objects. The editing process may require some thought. This may require downtime for applications that rely on the feature.
      </li>
      <li>
        Recommended for only non-business-critical uses because of potential for incompatible changes in subsequent releases. If you have multiple clusters that can be upgraded independently, you may be able to relax this restriction.
      </li>
      <li>
        <strong>
          Please do try our beta features and give feedback on them! After they exit beta, it may not be practical for us to make more changes.
        </strong>
      </li>
    </ul>
  </div>
  <script>
    $(function(){

    $( "#feature-state-dialog" ).dialog({
    autoOpen: false,
    width: "600",
    buttons: [
    {
    text: "Ok",
    click: function() {
    $( this ).dialog( "close" );
    }
    }
    ]
    });


    $( "#feature-state-dialog-link" ).click(function( event ) {
    $( "#feature-state-dialog" ).dialog( "open" );
    event.preventDefault();
    });

    });
  </script>
</div>
<p>
  EndpointSlices are an API resource that can provide a more scalable alternative
  to Endpoints. Although conceptually quite similar to Endpoints, EndpointSlices
  allow for distributing network endpoints across multiple resources. By default,
  an EndpointSlice is considered &ldquo;full&rdquo; once it reaches 100 endpoints, at which
  point additional EndpointSlices will be created to store any additional
  endpoints.
</p>
<p>
  EndpointSlices provide additional attributes and functionality which is
  described in detail in
  <a href="/docs/concepts/services-networking/endpoint-slices/">
    EndpointSlices
  </a>
  .
</p>
<h3 id="application-protocol">
  Application protocol
</h3>
<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>
    FEATURE STATE:
  </b>
  <code>
    Kubernetes v1.18
  </code>
  <a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all">
    <span class="ui-icon ui-icon-newwin"></span>
    alpha
  </a>
  <div id="feature-state-dialog" class="ui-dialog-content" title="alpha">
    <p>
      This feature is currently in a
      <em>
        alpha
      </em>
      state, meaning:
    </p>
    <ul>
      <li>
        The version names contain alpha (e.g. v1alpha1).
      </li>
      <li>
        Might be buggy. Enabling the feature may expose bugs. Disabled by default.
      </li>
      <li>
        Support for feature may be dropped at any time without notice.
      </li>
      <li>
        The API may change in incompatible ways in a later software release without notice.
      </li>
      <li>
        Recommended for use only in short-lived testing clusters, due to increased risk of bugs and lack of long-term support.
      </li>
    </ul>
  </div>
  <script>
    $(function(){

    $( "#feature-state-dialog" ).dialog({
    autoOpen: false,
    width: "600",
    buttons: [
    {
    text: "Ok",
    click: function() {
    $( this ).dialog( "close" );
    }
    }
    ]
    });


    $( "#feature-state-dialog-link" ).click(function( event ) {
    $( "#feature-state-dialog" ).dialog( "open" );
    event.preventDefault();
    });

    });
  </script>
</div>
<p>
  The AppProtocol field provides a way to specify an application protocol to be
  used for each Service port.
</p>
<p>
  As an alpha feature, this field is not enabled by default. To use this field,
  enable the
  <code>
    ServiceAppProtocol
  </code>
  <a href="/docs/reference/command-line-tools-reference/feature-gates/">
    feature
    gate
  </a>
  .
</p>
<h2 id="virtual-ips-and-service-proxies">
  Virtual IPs and service proxies
</h2>
<p>
  Every node in a Kubernetes cluster runs a
  <code>
    kube-proxy
  </code>
  .
  <code>
    kube-proxy
  </code>
  is
  responsible for implementing a form of virtual IP for
  <code>
    Services
  </code>
  of type other
  than
  <a href="#externalname">
    <code>
      ExternalName
    </code>
  </a>
  .
</p>
<h3 id="why-not-use-round-robin-dns">
  Why not use round-robin DNS?
</h3>
<p>
  A question that pops up every now and then is why Kubernetes relies on
  proxying to forward inbound traffic to backends. What about other
  approaches? For example, would it be possible to configure DNS records that
  have multiple A values (or AAAA for IPv6), and rely on round-robin name
  resolution?
</p>
<p>
  There are a few reasons for using proxying for Services:
</p>
<ul>
  <li>
    There is a long history of DNS implementations not respecting record TTLs,
    and caching the results of name lookups after they should have expired.
  </li>
  <li>
    Some apps do DNS lookups only once and cache the results indefinitely.
  </li>
  <li>
    Even if apps and libraries did proper re-resolution, the low or zero TTLs
    on the DNS records could impose a high load on DNS that then becomes
    difficult to manage.
  </li>
</ul>
<h3 id="proxy-mode-userspace">
  User space proxy mode
</h3>
<p>
  In this mode, kube-proxy watches the Kubernetes master for the addition and
  removal of Service and Endpoint objects. For each Service it opens a
  port (randomly chosen) on the local node.  Any connections to this &ldquo;proxy port&rdquo;
  are
  proxied to one of the Service&rsquo;s backend Pods (as reported via
  Endpoints). kube-proxy takes the
  <code>
    SessionAffinity
  </code>
  setting of the Service into
  account when deciding which backend Pod to use.
</p>
<p>
  Lastly, the user-space proxy installs iptables rules which capture traffic to
  the Service&rsquo;s
  <code>
    clusterIP
  </code>
  (which is virtual) and
  <code>
    port
  </code>
  . The rules
  redirect that traffic to the proxy port which proxies the backend Pod.
</p>
<p>
  By default, kube-proxy in userspace mode chooses a backend via a round-robin algorithm.
</p>
<p>
  <img src="/images/docs/services-userspace-overview.svg" alt="Services overview diagram for userspace proxy" />
</p>
<h3 id="proxy-mode-iptables">
  <code>
    iptables
  </code>
  proxy mode
</h3>
<p>
  In this mode, kube-proxy watches the Kubernetes control plane for the addition and
  removal of Service and Endpoint objects. For each Service, it installs
  iptables rules, which capture traffic to the Service&rsquo;s
  <code>
    clusterIP
  </code>
  and
  <code>
    port
  </code>
  ,
  and redirect that traffic to one of the Service&rsquo;s
  backend sets.  For each Endpoint object, it installs iptables rules which
  select a backend Pod.
</p>
<p>
  By default, kube-proxy in iptables mode chooses a backend at random.
</p>
<p>
  Using iptables to handle traffic has a lower system overhead, because traffic
  is handled by Linux netfilter without the need to switch between userspace and the
  kernel space. This approach is also likely to be more reliable.
</p>
<p>
  If kube-proxy is running in iptables mode and the first Pod that&rsquo;s selected
  does not respond, the connection fails. This is different from userspace
  mode: in that scenario, kube-proxy would detect that the connection to the first
  Pod had failed and would automatically retry with a different backend Pod.
</p>
<p>
  You can use Pod
  <a href="/docs/concepts/workloads/pods/pod-lifecycle/#container-probes">
    readiness probes
  </a>
  to verify that backend Pods are working OK, so that kube-proxy in iptables mode
  only sees backends that test out as healthy. Doing this means you avoid
  having traffic sent via kube-proxy to a Pod that&rsquo;s known to have failed.
</p>
<p>
  <img src="/images/docs/services-iptables-overview.svg" alt="Services overview diagram for iptables proxy" />
</p>
<h3 id="proxy-mode-ipvs">
  IPVS proxy mode
</h3>
<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>
    FEATURE STATE:
  </b>
  <code>
    Kubernetes v1.11
  </code>
  <a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all">
    <span class="ui-icon ui-icon-newwin"></span>
    stable
  </a>
  <div id="feature-state-dialog" class="ui-dialog-content" title="stable">
    <p>
      This feature is
      <em>
        stable
      </em>
      , meaning:
    </p>
    <ul>
      <li>
        The version name is vX where X is an integer.
      </li>
      <li>
        Stable versions of features will appear in released software for many subsequent versions.
      </li>
    </ul>
  </div>
  <script>
    $(function(){

    $( "#feature-state-dialog" ).dialog({
    autoOpen: false,
    width: "600",
    buttons: [
    {
    text: "Ok",
    click: function() {
    $( this ).dialog( "close" );
    }
    }
    ]
    });


    $( "#feature-state-dialog-link" ).click(function( event ) {
    $( "#feature-state-dialog" ).dialog( "open" );
    event.preventDefault();
    });

    });
  </script>
</div>
<p>
  In
  <code>
    ipvs
  </code>
  mode, kube-proxy watches Kubernetes Services and Endpoints,
  calls
  <code>
    netlink
  </code>
  interface to create IPVS rules accordingly and synchronizes
  IPVS rules with Kubernetes Services and Endpoints periodically.
  This control loop ensures that IPVS status matches the desired
  state.
  When accessing a Service, IPVS directs traffic to one of the backend Pods.
</p>
<p>
  The IPVS proxy mode is based on netfilter hook function that is similar to
  iptables mode, but uses a hash table as the underlying data structure and works
  in the kernel space.
  That means kube-proxy in IPVS mode redirects traffic with lower latency than
  kube-proxy in iptables mode, with much better performance when synchronising
  proxy rules. Compared to the other proxy modes, IPVS mode also supports a
  higher throughput of network traffic.
</p>
<p>
  IPVS provides more options for balancing traffic to backend Pods;
  these are:
</p>
<ul>
  <li>
    <code>
      rr
    </code>
    : round-robin
  </li>
  <li>
    <code>
      lc
    </code>
    : least connection (smallest number of open connections)
  </li>
  <li>
    <code>
      dh
    </code>
    : destination hashing
  </li>
  <li>
    <code>
      sh
    </code>
    : source hashing
  </li>
  <li>
    <code>
      sed
    </code>
    : shortest expected delay
  </li>
  <li>
    <code>
      nq
    </code>
    : never queue
  </li>
</ul>
<blockquote class="note">
  <div>
    <strong>
      Note:
    </strong>
    <p>
      To run kube-proxy in IPVS mode, you must make the IPVS Linux available on
      the node before you starting kube-proxy.
    </p>
    <p>
      When kube-proxy starts in IPVS proxy mode, it verifies whether IPVS
      kernel modules are available. If the IPVS kernel modules are not detected, then kube-proxy
      falls back to running in iptables proxy mode.
    </p>
  </div>
</blockquote>
<p>
  <img src="/images/docs/services-ipvs-overview.svg" alt="Services overview diagram for IPVS proxy" />
</p>
<p>
  In these proxy models, the traffic bound for the Service’s IP:Port is
  proxied to an appropriate backend without the clients knowing anything
  about Kubernetes or Services or Pods.
</p>
<p>
  If you want to make sure that connections from a particular client
  are passed to the same Pod each time, you can select the session affinity based
  on the client&rsquo;s IP addresses by setting
  <code>
    service.spec.sessionAffinity
  </code>
  to &ldquo;ClientIP&rdquo;
  (the default is &ldquo;None&rdquo;).
  You can also set the maximum session sticky time by setting
  <code>
    service.spec.sessionAffinityConfig.clientIP.timeoutSeconds
  </code>
  appropriately.
  (the default value is 10800, which works out to be 3 hours).
</p>
<h2 id="multi-port-services">
  Multi-Port Services
</h2>
<p>
  For some Services, you need to expose more than one port.
  Kubernetes lets you configure multiple port definitions on a Service object.
  When using multiple ports for a Service, you must give all of your ports names
  so that these are unambiguous.
  For example:
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#a2f;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">app</span>:<span style="color:#bbb"> </span>MyApp<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">ports</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>http<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">protocol</span>:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">port</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">targetPort</span>:<span style="color:#bbb"> </span><span style="color:#666">9376</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>https<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">protocol</span>:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">port</span>:<span style="color:#bbb"> </span><span style="color:#666">443</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">targetPort</span>:<span style="color:#bbb"> </span><span style="color:#666">9377</span></code></pre>
</div>
<blockquote class="note">
  <div>
    <strong>
      Note:
    </strong>
    <p>
      As with Kubernetes
      <a class='glossary-tooltip' href='/docs/concepts/overview/working-with-objects/names' target='_blank'>
        names
        <span class='tooltip-text'>
          A client-provided string that refers to an object in a resource URL, such as /api/v1/pods/some-name.
        </span>
      </a>
      in general, names for ports
      must only contain lowercase alphanumeric characters and
      <code>
        -
      </code>
      . Port names must
      also start and end with an alphanumeric character.
    </p>
    <p>
      For example, the names
      <code>
        123-abc
      </code>
      and
      <code>
        web
      </code>
      are valid, but
      <code>
        123_abc
      </code>
      and
      <code>
        -web
      </code>
      are not.
    </p>
  </div>
</blockquote>
<h2 id="choosing-your-own-ip-address">
  Choosing your own IP address
</h2>
<p>
  You can specify your own cluster IP address as part of a
  <code>
    Service
  </code>
  creation
  request.  To do this, set the
  <code>
    .spec.clusterIP
  </code>
  field. For example, if you
  already have an existing DNS entry that you wish to reuse, or legacy systems
  that are configured for a specific IP address and difficult to re-configure.
</p>
<p>
  The IP address that you choose must be a valid IPv4 or IPv6 address from within the
  <code>
    service-cluster-ip-range
  </code>
  CIDR range that is configured for the API server.
  If you try to create a Service with an invalid clusterIP address value, the API
  server will return a 422 HTTP status code to indicate that there&rsquo;s a problem.
</p>
<h2 id="discovering-services">
  Discovering services
</h2>
<p>
  Kubernetes supports 2 primary modes of finding a Service - environment
  variables and DNS.
</p>
<h3 id="environment-variables">
  Environment variables
</h3>
<p>
  When a Pod is run on a Node, the kubelet adds a set of environment variables
  for each active Service.  It supports both
  <a href="https://docs.docker.com/userguide/dockerlinks/">
    Docker links
    compatible
  </a>
  variables (see
  <a href="http://releases.k8s.io/master/pkg/kubelet/envvars/envvars.go#L49">
    makeLinkVariables
  </a>
  )
  and simpler
  <code>
    {SVCNAME}_SERVICE_HOST
  </code>
  and
  <code>
    {SVCNAME}_SERVICE_PORT
  </code>
  variables,
  where the Service name is upper-cased and dashes are converted to underscores.
</p>
<p>
  For example, the Service
  <code>
    &quot;redis-master&quot;
  </code>
  which exposes TCP port 6379 and has been
  allocated cluster IP address 10.0.0.11, produces the following environment
  variables:
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">REDIS_MASTER_SERVICE_HOST</span><span style="color:#666">=</span>10.0.0.11
<span style="color:#b8860b">REDIS_MASTER_SERVICE_PORT</span><span style="color:#666">=</span><span style="color:#666">6379</span>
<span style="color:#b8860b">REDIS_MASTER_PORT</span><span style="color:#666">=</span>tcp://10.0.0.11:6379
<span style="color:#b8860b">REDIS_MASTER_PORT_6379_TCP</span><span style="color:#666">=</span>tcp://10.0.0.11:6379
<span style="color:#b8860b">REDIS_MASTER_PORT_6379_TCP_PROTO</span><span style="color:#666">=</span>tcp
<span style="color:#b8860b">REDIS_MASTER_PORT_6379_TCP_PORT</span><span style="color:#666">=</span><span style="color:#666">6379</span>
<span style="color:#b8860b">REDIS_MASTER_PORT_6379_TCP_ADDR</span><span style="color:#666">=</span>10.0.0.11</code></pre>
</div>
<blockquote class="note">
  <div>
    <strong>
      Note:
    </strong>
    <p>
      When you have a Pod that needs to access a Service, and you are using
      the environment variable method to publish the port and cluster IP to the client
      Pods, you must create the Service
      <em>
        before
      </em>
      the client Pods come into existence.
      Otherwise, those client Pods won&rsquo;t have their environment variables populated.
    </p>
    <p>
      If you only use DNS to discover the cluster IP for a Service, you don&rsquo;t need to
      worry about this ordering issue.
    </p>
  </div>
</blockquote>
<h3 id="dns">
  DNS
</h3>
<p>
  You can (and almost always should) set up a DNS service for your Kubernetes
  cluster using an
  <a href="/docs/concepts/cluster-administration/addons/">
    add-on
  </a>
  .
</p>
<p>
  A cluster-aware DNS server, such as CoreDNS, watches the Kubernetes API for new
  Services and creates a set of DNS records for each one.  If DNS has been enabled
  throughout your cluster then all Pods should automatically be able to resolve
  Services by their DNS name.
</p>
<p>
  For example, if you have a Service called
  <code>
    &quot;my-service&quot;
  </code>
  in a Kubernetes
  Namespace
  <code>
    &quot;my-ns&quot;
  </code>
  , the control plane and the DNS Service acting together
  create a DNS record for
  <code>
    &quot;my-service.my-ns&quot;
  </code>
  . Pods in the
  <code>
    &quot;my-ns&quot;
  </code>
  Namespace
  should be able to find it by simply doing a name lookup for
  <code>
    my-service
  </code>
  (
  <code>
    &quot;my-service.my-ns&quot;
  </code>
  would also work).
</p>
<p>
  Pods in other Namespaces must qualify the name as
  <code>
    my-service.my-ns
  </code>
  . These names
  will resolve to the cluster IP assigned for the Service.
</p>
<p>
  Kubernetes also supports DNS SRV (Service) records for named ports.  If the
  <code>
    &quot;my-service.my-ns&quot;
  </code>
  Service has a port named
  <code>
    &quot;http&quot;
  </code>
  with the protocol set to
  <code>
    TCP
  </code>
  , you can do a DNS SRV query for
  <code>
    _http._tcp.my-service.my-ns
  </code>
  to discover
  the port number for
  <code>
    &quot;http&quot;
  </code>
  , as well as the IP address.
</p>
<p>
  The Kubernetes DNS server is the only way to access
  <code>
    ExternalName
  </code>
  Services.
  You can find more information about
  <code>
    ExternalName
  </code>
  resolution in
  <a href="/docs/concepts/services-networking/dns-pod-service/">
    DNS Pods and Services
  </a>
  .
</p>
<h2 id="headless-services">
  Headless Services
</h2>
<p>
  Sometimes you don&rsquo;t need load-balancing and a single Service IP.  In
  this case, you can create what are termed “headless” Services, by explicitly
  specifying
  <code>
    &quot;None&quot;
  </code>
  for the cluster IP (
  <code>
    .spec.clusterIP
  </code>
  ).
</p>
<p>
  You can use a headless Service to interface with other service discovery mechanisms,
  without being tied to Kubernetes&rsquo; implementation.
</p>
<p>
  For headless
  <code>
    Services
  </code>
  , a cluster IP is not allocated, kube-proxy does not handle
  these Services, and there is no load balancing or proxying done by the platform
  for them. How DNS is automatically configured depends on whether the Service has
  selectors defined:
</p>
<h3 id="with-selectors">
  With selectors
</h3>
<p>
  For headless Services that define selectors, the endpoints controller creates
  <code>
    Endpoints
  </code>
  records in the API, and modifies the DNS configuration to return
  records (addresses) that point directly to the
  <code>
    Pods
  </code>
  backing the
  <code>
    Service
  </code>
  .
</p>
<h3 id="without-selectors">
  Without selectors
</h3>
<p>
  For headless Services that do not define selectors, the endpoints controller does
  not create
  <code>
    Endpoints
  </code>
  records. However, the DNS system looks for and configures
  either:
</p>
<ul>
  <li>
    CNAME records for
    <a href="#externalname">
      <code>
        ExternalName
      </code>
    </a>
    -type Services.
  </li>
  <li>
    A records for any
    <code>
      Endpoints
    </code>
    that share a name with the Service, for all
    other types.
  </li>
</ul>
<h2 id="publishing-services-service-types">
  Publishing Services (ServiceTypes)
</h2>
<p>
  For some parts of your application (for example, frontends) you may want to expose a
  Service onto an external IP address, that&rsquo;s outside of your cluster.
</p>
<p>
  Kubernetes
  <code>
    ServiceTypes
  </code>
  allow you to specify what kind of Service you want.
  The default is
  <code>
    ClusterIP
  </code>
  .
</p>
<p>
  <code>
    Type
  </code>
  values and their behaviors are:
</p>
<ul>
  <li>
    <code>
      ClusterIP
    </code>
    : Exposes the Service on a cluster-internal IP. Choosing this value
    makes the Service only reachable from within the cluster. This is the
    default
    <code>
      ServiceType
    </code>
    .
  </li>
  <li>
    <a href="#nodeport">
      <code>
        NodePort
      </code>
    </a>
    : Exposes the Service on each Node&rsquo;s IP at a static port
    (the
    <code>
      NodePort
    </code>
    ). A
    <code>
      ClusterIP
    </code>
    Service, to which the
    <code>
      NodePort
    </code>
    Service
    routes, is automatically created.  You&rsquo;ll be able to contact the
    <code>
      NodePort
    </code>
    Service,
    from outside the cluster,
    by requesting
    <code>
      &lt;NodeIP&gt;:&lt;NodePort&gt;
    </code>
    .
  </li>
  <li>
    <a href="#loadbalancer">
      <code>
        LoadBalancer
      </code>
    </a>
    : Exposes the Service externally using a cloud
    provider&rsquo;s load balancer.
    <code>
      NodePort
    </code>
    and
    <code>
      ClusterIP
    </code>
    Services, to which the external
    load balancer routes, are automatically created.
  </li>
  <li>
    <p>
      <a href="#externalname">
        <code>
          ExternalName
        </code>
      </a>
      : Maps the Service to the contents of the
      <code>
        externalName
      </code>
      field (e.g.
      <code>
        foo.bar.example.com
      </code>
      ), by returning a
      <code>
        CNAME
      </code>
      record
    </p>
    <p>
      with its value. No proxying of any kind is set up.
      <blockquote class="note">
        <div>
          <strong>
            Note:
          </strong>
          You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the
          <code>
            ExternalName
          </code>
          type.
        </div>
      </blockquote>
    </p>
  </li>
</ul>
<p>
  You can also use
  <a href="/docs/concepts/services-networking/ingress/">
    Ingress
  </a>
  to expose your Service. Ingress is not a Service type, but it acts as the entry point for your cluster. It lets you consolidate your routing rules into a single resource as it can expose multiple services under the same IP address.
</p>
<h3 id="nodeport">
  Type NodePort
</h3>
<p>
  If you set the
  <code>
    type
  </code>
  field to
  <code>
    NodePort
  </code>
  , the Kubernetes control plane
  allocates a port from a range specified by
  <code>
    --service-node-port-range
  </code>
  flag (default: 30000-32767).
  Each node proxies that port (the same port number on every Node) into your Service.
  Your Service reports the allocated port in its
  <code>
    .spec.ports[*].nodePort
  </code>
  field.
</p>
<p>
  If you want to specify particular IP(s) to proxy the port, you can set the
  <code>
    --nodeport-addresses
  </code>
  flag in kube-proxy to particular IP block(s); this is supported since Kubernetes v1.10.
  This flag takes a comma-delimited list of IP blocks (e.g. 10.0.0.0/8, 192.0.2.0/25) to specify IP address ranges that kube-proxy should consider as local to this node.
</p>
<p>
  For example, if you start kube-proxy with the
  <code>
    --nodeport-addresses=127.0.0.0/8
  </code>
  flag, kube-proxy only selects the loopback interface for NodePort Services. The default for
  <code>
    --nodeport-addresses
  </code>
  is an empty list. This means that kube-proxy should consider all available network interfaces for NodePort. (That&rsquo;s also compatible with earlier Kubernetes releases).
</p>
<p>
  If you want a specific port number, you can specify a value in the
  <code>
    nodePort
  </code>
  field. The control plane will either allocate you that port or report that
  the API transaction failed.
  This means that you need to take care of possible port collisions yourself.
  You also have to use a valid port number, one that&rsquo;s inside the range configured
  for NodePort use.
</p>
<p>
  Using a NodePort gives you the freedom to set up your own load balancing solution,
  to configure environments that are not fully supported by Kubernetes, or even
  to just expose one or more nodes&rsquo; IPs directly.
</p>
<p>
  Note that this Service is visible as
  <code>
    &lt;NodeIP&gt;:spec.ports[*].nodePort
  </code>
  and
  <code>
    .spec.clusterIP:spec.ports[*].port
  </code>
  . (If the
  <code>
    --nodeport-addresses
  </code>
  flag in kube-proxy is set,
  <NodeIP>
  would be filtered NodeIP(s).)
</p>
<p>
  For example:
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#a2f;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">type</span>:<span style="color:#bbb"> </span>NodePort<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">app</span>:<span style="color:#bbb"> </span>MyApp<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">ports</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># By default and for convenience, the `targetPort` is set to the same value as the `port` field.</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#a2f;font-weight:bold">port</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">targetPort</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># Optional field</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># By default and for convenience, the Kubernetes control plane will allocate a port from a range (default: 30000-32767)</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">nodePort</span>:<span style="color:#bbb"> </span><span style="color:#666">30007</span></code></pre>
</div>
<h3 id="loadbalancer">
  Type LoadBalancer
</h3>
<p>
  On cloud providers which support external load balancers, setting the
  <code>
    type
  </code>
  field to
  <code>
    LoadBalancer
  </code>
  provisions a load balancer for your Service.
  The actual creation of the load balancer happens asynchronously, and
  information about the provisioned balancer is published in the Service&rsquo;s
  <code>
    .status.loadBalancer
  </code>
  field.
  For example:
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#a2f;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">app</span>:<span style="color:#bbb"> </span>MyApp<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">ports</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#a2f;font-weight:bold">protocol</span>:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">port</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">targetPort</span>:<span style="color:#bbb"> </span><span style="color:#666">9376</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">clusterIP</span>:<span style="color:#bbb"> </span><span style="color:#666">10.0.171.239</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">type</span>:<span style="color:#bbb"> </span>LoadBalancer<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">status</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">loadBalancer</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">ingress</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#a2f;font-weight:bold">ip</span>:<span style="color:#bbb"> </span><span style="color:#666">192.0.2.127</span></code></pre>
</div>
<p>
  Traffic from the external load balancer is directed at the backend Pods. The cloud provider decides how it is load balanced.
</p>
<p>
  For LoadBalancer type of Services, when there is more than one port defined, all
  ports must have the same protocol and the protocol must be one of
  <code>
    TCP
  </code>
  ,
  <code>
    UDP
  </code>
  ,
  and
  <code>
    SCTP
  </code>
  .
</p>
<p>
  Some cloud providers allow you to specify the
  <code>
    loadBalancerIP
  </code>
  . In those cases, the load-balancer is created
  with the user-specified
  <code>
    loadBalancerIP
  </code>
  . If the
  <code>
    loadBalancerIP
  </code>
  field is not specified,
  the loadBalancer is set up with an ephemeral IP address. If you specify a
  <code>
    loadBalancerIP
  </code>
  but your cloud provider does not support the feature, the
  <code>
    loadbalancerIP
  </code>
  field that you
  set is ignored.
</p>
<blockquote class="note">
  <div>
    <strong>
      Note:
    </strong>
    If you&rsquo;re using SCTP, see the
    <a href="#caveat-sctp-loadbalancer-service-type">
      caveat
    </a>
    below about the
    <code>
      LoadBalancer
    </code>
    Service type.
  </div>
</blockquote>
<blockquote class="note">
  <div>
    <strong>
      Note:
    </strong>
    <p>
      On
      <strong>
        Azure
      </strong>
      , if you want to use a user-specified public type
      <code>
        loadBalancerIP
      </code>
      , you first need
      to create a static type public IP address resource. This public IP address resource should
      be in the same resource group of the other automatically created resources of the cluster.
      For example,
      <code>
        MC_myResourceGroup_myAKSCluster_eastus
      </code>
      .
    </p>
    <p>
      Specify the assigned IP address as loadBalancerIP. Ensure that you have updated the securityGroupName in the cloud provider configuration file. For information about troubleshooting
      <code>
        CreatingLoadBalancerFailed
      </code>
      permission issues see,
      <a href="https://docs.microsoft.com/en-us/azure/aks/static-ip">
        Use a static IP address with the Azure Kubernetes Service (AKS) load balancer
      </a>
      or
      <a href="https://github.com/Azure/AKS/issues/357">
        CreatingLoadBalancerFailed on AKS cluster with advanced networking
      </a>
      .
    </p>
  </div>
</blockquote>
<h4 id="internal-load-balancer">
  Internal load balancer
</h4>
<p>
  In a mixed environment it is sometimes necessary to route traffic from Services inside the same
  (virtual) network address block.
</p>
<p>
  In a split-horizon DNS environment you would need two Services to be able to route both external and internal traffic to your endpoints.
</p>
<p>
  You can achieve this by adding one the following annotations to a Service.
  The annotation to add depends on the cloud Service provider you&rsquo;re using.
</p>
<div id="service-tabs">
<ul>
  <li>
    <a href="#service-tabs-0">
      Default
    </a>
  </li>
  <li>
    <a href="#service-tabs-1">
      GCP
    </a>
  </li>
  <li>
    <a href="#service-tabs-2">
      AWS
    </a>
  </li>
  <li>
    <a href="#service-tabs-3">
      Azure
    </a>
  </li>
  <li>
    <a href="#service-tabs-4">
      OpenStack
    </a>
  </li>
  <li>
    <a href="#service-tabs-5">
      Baidu Cloud
    </a>
  </li>
  <li>
    <a href="#service-tabs-6">
      Tencent Cloud
    </a>
  </li>
</ul>
<div id="service-tabs-0">
  <p>
    Select one of the tabs.
  </p>
</div>
<div id="service-tabs-1">
  <div class="highlight">
    <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">cloud.google.com/load-balancer-type</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Internal&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre>
  </div>
  <p>
</div>
<div id="service-tabs-2">
  <div class="highlight">
    <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-internal</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre>
  </div>
  <p>
</div>
<div id="service-tabs-3">
  <div class="highlight">
    <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/azure-load-balancer-internal</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre>
  </div>
  <p>
</div>
<div id="service-tabs-4">
  <div class="highlight">
    <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/openstack-internal-load-balancer</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre>
  </div>
  <p>
</div>
<div id="service-tabs-5">
  <div class="highlight">
    <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/cce-load-balancer-internal-vpc</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre>
  </div>
  <p>
</div>
<div id="service-tabs-6">
  <div class="highlight">
    <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">annotations</span>:<span style="color:#bbb">  
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">service.kubernetes.io/qcloud-loadbalancer-internal-subnetid</span>:<span style="color:#bbb"> </span>subnet-xxxxx<span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre>
  </div>
  <p>
</div>
<p>
<script>
  $(function(){$("#service-tabs").tabs();});
</script>
<h4 id="ssl-support-on-aws">
  TLS support on AWS
</h4>
<p>
  For partial TLS / SSL support on clusters running on AWS, you can add three
  annotations to a
  <code>
    LoadBalancer
  </code>
  service:
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-ssl-cert</span>:<span style="color:#bbb"> </span>arn:aws:acm:us-east<span style="color:#666">-1</span>:<span style="color:#666">123456789012</span>:certificate/<span style="color:#666">12345678-1234-1234-1234-123456789012</span></code></pre>
</div>
<p>
  The first specifies the ARN of the certificate to use. It can be either a
  certificate from a third party issuer that was uploaded to IAM or one created
  within AWS Certificate Manager.
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style="color:#bbb"> </span>(https|http|ssl|tcp)</code></pre>
</div>
<p>
  The second annotation specifies which protocol a Pod speaks. For HTTPS and
  SSL, the ELB expects the Pod to authenticate itself over the encrypted
  connection, using a certificate.
</p>
<p>
  HTTP and HTTPS selects layer 7 proxying: the ELB terminates
  the connection with the user, parses headers, and injects the
  <code>
    X-Forwarded-For
  </code>
  header with the user&rsquo;s IP address (Pods only see the IP address of the
  ELB at the other end of its connection) when forwarding requests.
</p>
<p>
  TCP and SSL selects layer 4 proxying: the ELB forwards traffic without
  modifying the headers.
</p>
<p>
  In a mixed-use environment where some ports are secured and others are left unencrypted,
  you can use the following annotations:
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style="color:#bbb"> </span>http<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-ssl-ports</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;443,8443&#34;</span></code></pre>
</div>
<p>
  In the above example, if the Service contained three ports,
  <code>
    80
  </code>
  ,
  <code>
    443
  </code>
  , and
  <code>
    8443
  </code>
  , then
  <code>
    443
  </code>
  and
  <code>
    8443
  </code>
  would use the SSL certificate, but
  <code>
    80
  </code>
  would just
  be proxied HTTP.
</p>
<p>
  From Kubernetes v1.9 onwards you can use
  <a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-security-policy-table.html">
    predefined AWS SSL policies
  </a>
  with HTTPS or SSL listeners for your Services.
  To see which policies are available for use, you can use the
  <code>
    aws
  </code>
  command line tool:
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">aws elb describe-load-balancer-policies --query <span style="color:#b44">&#39;PolicyDescriptions[].PolicyName&#39;</span></code></pre>
</div>
<p>
  You can then specify any one of those policies using the
  &ldquo;
  <code>
    service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy
  </code>
  &ldquo;
  annotation; for example:
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;ELBSecurityPolicy-TLS-1-2-2017-01&#34;</span></code></pre>
</div>
<h4 id="proxy-protocol-support-on-aws">
  PROXY protocol support on AWS
</h4>
<p>
  To enable
  <a href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt">
    PROXY protocol
  </a>
  support for clusters running on AWS, you can use the following service
  annotation:
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-proxy-protocol</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;*&#34;</span></code></pre>
</div>
<p>
  Since version 1.3.0, the use of this annotation applies to all ports proxied by the ELB
  and cannot be configured otherwise.
</p>
<h4 id="elb-access-logs-on-aws">
  ELB Access Logs on AWS
</h4>
<p>
  There are several annotations to manage access logs for ELB Services on AWS.
</p>
<p>
  The annotation
  <code>
    service.beta.kubernetes.io/aws-load-balancer-access-log-enabled
  </code>
  controls whether access logs are enabled.
</p>
<p>
  The annotation
  <code>
    service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval
  </code>
  controls the interval in minutes for publishing the access logs. You can specify
  an interval of either 5 or 60 minutes.
</p>
<p>
  The annotation
  <code>
    service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name
  </code>
  controls the name of the Amazon S3 bucket where load balancer access logs are
  stored.
</p>
<p>
  The annotation
  <code>
    service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix
  </code>
  specifies the logical hierarchy you created for your Amazon S3 bucket.
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Specifies whether access logs are enabled for the load balancer</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;60&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># The interval for publishing the access logs. You can specify an interval of either 5 or 60 (minutes).</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;my-bucket&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># The name of the Amazon S3 bucket where the access logs are stored</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;my-bucket-prefix/prod&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># The logical hierarchy you created for your Amazon S3 bucket, for example `my-bucket-prefix/prod`</span></code></pre>
</div>
<h4 id="connection-draining-on-aws">
  Connection Draining on AWS
</h4>
<p>
  Connection draining for Classic ELBs can be managed with the annotation
  <code>
    service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled
  </code>
  set
  to the value of
  <code>
    &quot;true&quot;
  </code>
  . The annotation
  <code>
    service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout
  </code>
  can
  also be used to set maximum time, in seconds, to keep the existing connections open before deregistering the instances.
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;60&#34;</span></code></pre>
</div>
<h4 id="other-elb-annotations">
  Other ELB annotations
</h4>
<p>
  There are other annotations to manage Classic Elastic Load Balancers that are described below.
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;60&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># The time, in seconds, that the connection is allowed to be idle (no data has been sent over the connection) before it is closed by the load balancer</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Specifies whether cross-zone load balancing is enabled for the load balancer</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;environment=prod,owner=devops&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># A comma-separated list of key-value pairs which will be recorded as</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># additional tags in the ELB.</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># The number of successive successful health checks required for a backend to</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># be considered healthy for traffic. Defaults to 2, must be between 2 and 10</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;3&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># The number of unsuccessful health checks required for a backend to be</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># considered unhealthy for traffic. Defaults to 6, must be between 2 and 10</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;20&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># The approximate interval, in seconds, between health checks of an</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># individual instance. Defaults to 10, must be between 5 and 300</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;5&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># The amount of time, in seconds, during which no response means a failed</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># health check. This value must be less than the service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># value. Defaults to 5, must be between 2 and 60</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-extra-security-groups</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;sg-53fae93f,sg-42efd82e&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># A list of additional security groups to be added to the ELB</span></code></pre>
</div>
<h4 id="aws-nlb-support">
  Network Load Balancer support on AWS
</h4>
<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>
    FEATURE STATE:
  </b>
  <code>
    Kubernetes v1.15
  </code>
  <a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all">
    <span class="ui-icon ui-icon-newwin"></span>
    beta
  </a>
  <div id="feature-state-dialog" class="ui-dialog-content" title="beta">
    <p>
      This feature is currently in a
      <em>
        beta
      </em>
      state, meaning:
    </p>
    <ul>
      <li>
        The version names contain beta (e.g. v2beta3).
      </li>
      <li>
        Code is well tested. Enabling the feature is considered safe. Enabled by default.
      </li>
      <li>
        Support for the overall feature will not be dropped, though details may change.
      </li>
      <li>
        The schema and/or semantics of objects may change in incompatible ways in a subsequent beta or stable release. When this happens, we will provide instructions for migrating to the next version. This may require deleting, editing, and re-creating API objects. The editing process may require some thought. This may require downtime for applications that rely on the feature.
      </li>
      <li>
        Recommended for only non-business-critical uses because of potential for incompatible changes in subsequent releases. If you have multiple clusters that can be upgraded independently, you may be able to relax this restriction.
      </li>
      <li>
        <strong>
          Please do try our beta features and give feedback on them! After they exit beta, it may not be practical for us to make more changes.
        </strong>
      </li>
    </ul>
  </div>
  <script>
    $(function(){

    $( "#feature-state-dialog" ).dialog({
    autoOpen: false,
    width: "600",
    buttons: [
    {
    text: "Ok",
    click: function() {
    $( this ).dialog( "close" );
    }
    }
    ]
    });


    $( "#feature-state-dialog-link" ).click(function( event ) {
    $( "#feature-state-dialog" ).dialog( "open" );
    event.preventDefault();
    });

    });
  </script>
</div>
<p>
  To use a Network Load Balancer on AWS, use the annotation
  <code>
    service.beta.kubernetes.io/aws-load-balancer-type
  </code>
  with the value set to
  <code>
    nlb
  </code>
  .
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.beta.kubernetes.io/aws-load-balancer-type</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;nlb&#34;</span></code></pre>
</div>
<blockquote class="note">
  <div>
    <strong>
      Note:
    </strong>
    NLB only works with certain instance classes; see the
    <a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/network/target-group-register-targets.html#register-deregister-targets">
      AWS documentation
    </a>
    on Elastic Load Balancing for a list of supported instance types.
  </div>
</blockquote>
<p>
  Unlike Classic Elastic Load Balancers, Network Load Balancers (NLBs) forward the
  client&rsquo;s IP address through to the node. If a Service&rsquo;s
  <code>
    .spec.externalTrafficPolicy
  </code>
  is set to
  <code>
    Cluster
  </code>
  , the client&rsquo;s IP address is not propagated to the end
  Pods.
</p>
<p>
  By setting
  <code>
    .spec.externalTrafficPolicy
  </code>
  to
  <code>
    Local
  </code>
  , the client IP addresses is
  propagated to the end Pods, but this could result in uneven distribution of
  traffic. Nodes without any Pods for a particular LoadBalancer Service will fail
  the NLB Target Group&rsquo;s health check on the auto-assigned
  <code>
    .spec.healthCheckNodePort
  </code>
  and not receive any traffic.
</p>
<p>
  In order to achieve even traffic, either use a DaemonSet or specify a
  <a href="/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity">
    pod anti-affinity
  </a>
  to not locate on the same node.
</p>
<p>
  You can also use NLB Services with the
  <a href="/docs/concepts/services-networking/service/#internal-load-balancer">
    internal load balancer
  </a>
  annotation.
</p>
<p>
  In order for client traffic to reach instances behind an NLB, the Node security
  groups are modified with the following IP rules:
</p>
<table>
  <thead>
    <tr>
      <th>
        Rule
      </th>
      <th>
        Protocol
      </th>
      <th>
        Port(s)
      </th>
      <th>
        IpRange(s)
      </th>
      <th>
        IpRange Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        Health Check
      </td>
      <td>
        TCP
      </td>
      <td>
        NodePort(s) (
        <code>
          .spec.healthCheckNodePort
        </code>
        for
        <code>
          .spec.externalTrafficPolicy = Local
        </code>
        )
      </td>
      <td>
        VPC CIDR
      </td>
      <td>
        kubernetes.io/rule/nlb/health=&lt;loadBalancerName&gt;
      </td>
    </tr>
    <tr>
      <td>
        Client Traffic
      </td>
      <td>
        TCP
      </td>
      <td>
        NodePort(s)
      </td>
      <td>
        <code>
          .spec.loadBalancerSourceRanges
        </code>
        (defaults to
        <code>
          0.0.0.0/0
        </code>
        )
      </td>
      <td>
        kubernetes.io/rule/nlb/client=&lt;loadBalancerName&gt;
      </td>
    </tr>
    <tr>
      <td>
        MTU Discovery
      </td>
      <td>
        ICMP
      </td>
      <td>
        3,4
      </td>
      <td>
        <code>
          .spec.loadBalancerSourceRanges
        </code>
        (defaults to
        <code>
          0.0.0.0/0
        </code>
        )
      </td>
      <td>
        kubernetes.io/rule/nlb/mtu=&lt;loadBalancerName&gt;
      </td>
    </tr>
  </tbody>
</table>
<p>
  In order to limit which client IP&rsquo;s can access the Network Load Balancer,
  specify
  <code>
    loadBalancerSourceRanges
  </code>
  .
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#a2f;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">loadBalancerSourceRanges</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#b44">&#34;143.231.0.0/16&#34;</span></code></pre>
</div>
<blockquote class="note">
  <div>
    <strong>
      Note:
    </strong>
    If
    <code>
      .spec.loadBalancerSourceRanges
    </code>
    is not set, Kubernetes
    allows traffic from
    <code>
      0.0.0.0/0
    </code>
    to the Node Security Group(s). If nodes have
    public IP addresses, be aware that non-NLB traffic can also reach all instances
    in those modified security groups.
  </div>
</blockquote>
<h4 id="other-clb-annotations-on-tencent-kubernetes-engine-tke">
  Other CLB annotations on Tencent Kubernetes Engine (TKE)
</h4>
<p>
  There are other annotations for managing Cloud Load Balancers on TKE as shown below.
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Bind Loadbalancers with specified nodes</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.kubernetes.io/qcloud-loadbalancer-backends-label</span>:<span style="color:#bbb"> </span>key<span style="color:#bbb"> </span>in<span style="color:#bbb"> </span>(value1,<span style="color:#bbb"> </span>value2)<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># ID of an existing load balancer</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.kubernetes.io/tke-existed-lbid：lb-6swtxxxx<span style="color:#bbb">
</span><span style="color:#bbb">        
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Custom parameters for the load balancer (LB), does not support modification of LB type yet</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.kubernetes.io/service.extensiveParameters</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Custom parameters for the LB listener </span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.kubernetes.io/service.listenerParameters</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Specifies the type of Load balancer;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># valid values: classic (Classic Cloud Load Balancer) or application (Application Cloud Load Balancer)</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.kubernetes.io/loadbalance-type</span>:<span style="color:#bbb"> </span>xxxxx<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Specifies the public network bandwidth billing method; </span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># valid values: TRAFFIC_POSTPAID_BY_HOUR(bill-by-traffic) and BANDWIDTH_POSTPAID_BY_HOUR (bill-by-bandwidth).</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.kubernetes.io/qcloud-loadbalancer-internet-charge-type</span>:<span style="color:#bbb"> </span>xxxxxx<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Specifies the bandwidth value (value range: [1,2000] Mbps).</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.kubernetes.io/qcloud-loadbalancer-internet-max-bandwidth-out</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;10&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># When this annotation is set，the loadbalancers will only register nodes </span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># with pod running on it, otherwise all nodes will be registered.</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">service.kubernetes.io/local-svc-only-bind-node-with-pod</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span></code></pre>
</div>
<h3 id="externalname">
  Type ExternalName
</h3>
<p>
  Services of type ExternalName map a Service to a DNS name, not to a typical selector such as
  <code>
    my-service
  </code>
  or
  <code>
    cassandra
  </code>
  . You specify these Services with the
  <code>
    spec.externalName
  </code>
  parameter.
</p>
<p>
  This Service definition, for example, maps
  the
  <code>
    my-service
  </code>
  Service in the
  <code>
    prod
  </code>
  namespace to
  <code>
    my.database.example.com
  </code>
  :
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#a2f;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>prod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">type</span>:<span style="color:#bbb"> </span>ExternalName<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">externalName</span>:<span style="color:#bbb"> </span>my.database.example.com</code></pre>
</div>
<blockquote class="note">
  <div>
    <strong>
      Note:
    </strong>
    ExternalName accepts an IPv4 address string, but as a DNS names comprised of digits, not as an IP address. ExternalNames that resemble IPv4 addresses are not resolved by CoreDNS or ingress-nginx because ExternalName
    is intended to specify a canonical DNS name. To hardcode an IP address, consider using
    <a href="#headless-services">
      headless Services
    </a>
    .
  </div>
</blockquote>
<p>
  When looking up the host
  <code>
    my-service.prod.svc.cluster.local
  </code>
  , the cluster DNS Service
  returns a
  <code>
    CNAME
  </code>
  record with the value
  <code>
    my.database.example.com
  </code>
  . Accessing
  <code>
    my-service
  </code>
  works in the same way as other Services but with the crucial
  difference that redirection happens at the DNS level rather than via proxying or
  forwarding. Should you later decide to move your database into your cluster, you
  can start its Pods, add appropriate selectors or endpoints, and change the
  Service&rsquo;s
  <code>
    type
  </code>
  .
</p>
<blockquote class="warning">
  <div>
    <strong>
      Warning:
    </strong>
    <p>
      You may have trouble using ExternalName for some common protocols, including HTTP and HTTPS. If you use ExternalName then the hostname used by clients inside your cluster is different from the name that the ExternalName references.
    </p>
    <p>
      For protocols that use hostnames this difference may lead to errors or unexpected responses. HTTP requests will have a
      <code>
        Host:
      </code>
      header that the origin server does not recognize; TLS servers will not be able to provide a certificate matching the hostname that the client connected to.
    </p>
  </div>
</blockquote>
<blockquote class="note">
  <div>
    <strong>
      Note:
    </strong>
    This section is indebted to the
    <a href="https://akomljen.com/kubernetes-tips-part-1/">
      Kubernetes Tips - Part
      1
    </a>
    blog post from
    <a href="https://akomljen.com/">
      Alen Komljen
    </a>
    .
  </div>
</blockquote>
<h3 id="external-ips">
  External IPs
</h3>
<p>
  If there are external IPs that route to one or more cluster nodes, Kubernetes Services can be exposed on those
  <code>
    externalIPs
  </code>
  . Traffic that ingresses into the cluster with the external IP (as destination IP), on the Service port,
  will be routed to one of the Service endpoints.
  <code>
    externalIPs
  </code>
  are not managed by Kubernetes and are the responsibility
  of the cluster administrator.
</p>
<p>
  In the Service spec,
  <code>
    externalIPs
  </code>
  can be specified along with any of the
  <code>
    ServiceTypes
  </code>
  .
  In the example below, &ldquo;
  <code>
    my-service
  </code>
  &rdquo; can be accessed by clients on &ldquo;
  <code>
    80.11.12.10:80
  </code>
  &rdquo; (
  <code>
    externalIP:port
  </code>
  )
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#a2f;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">app</span>:<span style="color:#bbb"> </span>MyApp<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">ports</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>http<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">protocol</span>:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">port</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">targetPort</span>:<span style="color:#bbb"> </span><span style="color:#666">9376</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">externalIPs</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#666">80.11.12.10</span></code></pre>
</div>
<h2 id="shortcomings">
  Shortcomings
</h2>
<p>
  Using the userspace proxy for VIPs, work at small to medium scale, but will
  not scale to very large clusters with thousands of Services.  The
  <a href="http://issue.k8s.io/1107">
    original
    design proposal for portals
  </a>
  has more details on
  this.
</p>
<p>
  Using the userspace proxy obscures the source IP address of a packet accessing
  a Service.
  This makes some kinds of network filtering (firewalling) impossible.  The iptables
  proxy mode does not
  obscure in-cluster source IPs, but it does still impact clients coming through
  a load balancer or node-port.
</p>
<p>
  The
  <code>
    Type
  </code>
  field is designed as nested functionality - each level adds to the
  previous.  This is not strictly required on all cloud providers (e.g. Google Compute Engine does
  not need to allocate a
  <code>
    NodePort
  </code>
  to make
  <code>
    LoadBalancer
  </code>
  work, but AWS does)
  but the current API requires it.
</p>
<h2 id="the-gory-details-of-virtual-ips">
  Virtual IP implementation
</h2>
<p>
  The previous information should be sufficient for many people who just want to
  use Services.  However, there is a lot going on behind the scenes that may be
  worth understanding.
</p>
<h3 id="avoiding-collisions">
  Avoiding collisions
</h3>
<p>
  One of the primary philosophies of Kubernetes is that you should not be
  exposed to situations that could cause your actions to fail through no fault
  of your own. For the design of the Service resource, this means not making
  you choose your own port number if that choice might collide with
  someone else&rsquo;s choice.  That is an isolation failure.
</p>
<p>
  In order to allow you to choose a port number for your Services, we must
  ensure that no two Services can collide. Kubernetes does that by allocating each
  Service its own IP address.
</p>
<p>
  To ensure each Service receives a unique IP, an internal allocator atomically
  updates a global allocation map in
  <a class='glossary-tooltip' href='/docs/tasks/administer-cluster/configure-upgrade-etcd/' target='_blank'>
    etcd
    <span class='tooltip-text'>
      Consistent and highly-available key value store used as Kubernetes&rsquo; backing store for all cluster data.
    </span>
  </a>
  prior to creating each Service. The map object must exist in the registry for
  Services to get IP address assignments, otherwise creations will
  fail with a message indicating an IP address could not be allocated.
</p>
<p>
  In the control plane, a background controller is responsible for creating that
  map (needed to support migrating from older versions of Kubernetes that used
  in-memory locking). Kubernetes also uses controllers to checking for invalid
  assignments (eg due to administrator intervention) and for cleaning up allocated
  IP addresses that are no longer used by any Services.
</p>
<h3 id="ips-and-vips">
  Service IP addresses
</h3>
<p>
  Unlike Pod IP addresses, which actually route to a fixed destination,
  Service IPs are not actually answered by a single host.  Instead, kube-proxy
  uses iptables (packet processing logic in Linux) to define
  <em>
    virtual
  </em>
  IP addresses
  which are transparently redirected as needed.  When clients connect to the
  VIP, their traffic is automatically transported to an appropriate endpoint.
  The environment variables and DNS for Services are actually populated in
  terms of the Service&rsquo;s virtual IP address (and port).
</p>
<p>
  kube-proxy supports three proxy modes&mdash;userspace, iptables and IPVS&mdash;which
  each operate slightly differently.
</p>
<h4 id="userspace">
  Userspace
</h4>
<p>
  As an example, consider the image processing application described above.
  When the backend Service is created, the Kubernetes master assigns a virtual
  IP address, for example 10.0.0.1.  Assuming the Service port is 1234, the
  Service is observed by all of the kube-proxy instances in the cluster.
  When a proxy sees a new Service, it opens a new random port, establishes an
  iptables redirect from the virtual IP address to this new port, and starts accepting
  connections on it.
</p>
<p>
  When a client connects to the Service&rsquo;s virtual IP address, the iptables
  rule kicks in, and redirects the packets to the proxy&rsquo;s own port.
  The “Service proxy” chooses a backend, and starts proxying traffic from the client to the backend.
</p>
<p>
  This means that Service owners can choose any port they want without risk of
  collision.  Clients can simply connect to an IP and port, without being aware
  of which Pods they are actually accessing.
</p>
<h4 id="iptables">
  iptables
</h4>
<p>
  Again, consider the image processing application described above.
  When the backend Service is created, the Kubernetes control plane assigns a virtual
  IP address, for example 10.0.0.1.  Assuming the Service port is 1234, the
  Service is observed by all of the kube-proxy instances in the cluster.
  When a proxy sees a new Service, it installs a series of iptables rules which
  redirect from the virtual IP address  to per-Service rules.  The per-Service
  rules link to per-Endpoint rules which redirect traffic (using destination NAT)
  to the backends.
</p>
<p>
  When a client connects to the Service&rsquo;s virtual IP address the iptables rule kicks in.
  A backend is chosen (either based on session affinity or randomly) and packets are
  redirected to the backend.  Unlike the userspace proxy, packets are never
  copied to userspace, the kube-proxy does not have to be running for the virtual
  IP address to work, and Nodes see traffic arriving from the unaltered client IP
  address.
</p>
<p>
  This same basic flow executes when traffic comes in through a node-port or
  through a load-balancer, though in those cases the client IP does get altered.
</p>
<h4 id="ipvs">
  IPVS
</h4>
<p>
  iptables operations slow down dramatically in large scale cluster e.g 10,000 Services.
  IPVS is designed for load balancing and based on in-kernel hash tables. So you can achieve performance consistency in large number of Services from IPVS-based kube-proxy. Meanwhile, IPVS-based kube-proxy has more sophisticated load balancing algorithms (least conns, locality, weighted, persistence).
</p>
<h2 id="api-object">
  API Object
</h2>
<p>
  Service is a top-level resource in the Kubernetes REST API. You can find more details
  about the API object at:
  <a href="/docs/reference/generated/kubernetes-api/v1.18/#service-v1-core">
    Service API object
  </a>
  .
</p>
<h2 id="protocol-support">
  Supported protocols
</h2>
<h3 id="tcp">
  TCP
</h3>
<p>
  You can use TCP for any kind of Service, and it&rsquo;s the default network protocol.
</p>
<h3 id="udp">
  UDP
</h3>
<p>
  You can use UDP for most Services. For type=LoadBalancer Services, UDP support
  depends on the cloud provider offering this facility.
</p>
<h3 id="http">
  HTTP
</h3>
<p>
  If your cloud provider supports it, you can use a Service in LoadBalancer mode
  to set up external HTTP / HTTPS reverse proxying, forwarded to the Endpoints
  of the Service.
</p>
<blockquote class="note">
  <div>
    <strong>
      Note:
    </strong>
    You can also use
    <a class='glossary-tooltip' href='/docs/concepts/services-networking/ingress/' target='_blank'>
      Ingress
      <span class='tooltip-text'>
        An API object that manages external access to the services in a cluster, typically HTTP.
      </span>
    </a>
    in place of Service
    to expose HTTP / HTTPS Services.
  </div>
</blockquote>
<h3 id="proxy-protocol">
  PROXY protocol
</h3>
<p>
  If your cloud provider supports it (eg,
  <a href="/docs/concepts/cluster-administration/cloud-providers/#aws">
    AWS
  </a>
  ),
  you can use a Service in LoadBalancer mode to configure a load balancer outside
  of Kubernetes itself, that will forward connections prefixed with
  <a href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt">
    PROXY protocol
  </a>
  .
</p>
<p>
  The load balancer will send an initial series of octets describing the
  incoming connection, similar to this example
</p><pre><code>PROXY TCP4 192.0.2.202 10.0.42.7 12345 7\r\n</code></pre>
<p>
  followed by the data from the client.
</p>
<h3 id="sctp">
  SCTP
</h3>
<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>
    FEATURE STATE:
  </b>
  <code>
    Kubernetes v1.12
  </code>
  <a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all">
    <span class="ui-icon ui-icon-newwin"></span>
    alpha
  </a>
  <div id="feature-state-dialog" class="ui-dialog-content" title="alpha">
    <p>
      This feature is currently in a
      <em>
        alpha
      </em>
      state, meaning:
    </p>
    <ul>
      <li>
        The version names contain alpha (e.g. v1alpha1).
      </li>
      <li>
        Might be buggy. Enabling the feature may expose bugs. Disabled by default.
      </li>
      <li>
        Support for feature may be dropped at any time without notice.
      </li>
      <li>
        The API may change in incompatible ways in a later software release without notice.
      </li>
      <li>
        Recommended for use only in short-lived testing clusters, due to increased risk of bugs and lack of long-term support.
      </li>
    </ul>
  </div>
  <script>
    $(function(){

    $( "#feature-state-dialog" ).dialog({
    autoOpen: false,
    width: "600",
    buttons: [
    {
    text: "Ok",
    click: function() {
    $( this ).dialog( "close" );
    }
    }
    ]
    });


    $( "#feature-state-dialog-link" ).click(function( event ) {
    $( "#feature-state-dialog" ).dialog( "open" );
    event.preventDefault();
    });

    });
  </script>
</div>
<p>
  Kubernetes supports SCTP as a
  <code>
    protocol
  </code>
  value in Service, Endpoint, NetworkPolicy and Pod definitions as an alpha feature. To enable this feature, the cluster administrator needs to enable the
  <code>
    SCTPSupport
  </code>
  feature gate on the apiserver, for example,
  <code>
    --feature-gates=SCTPSupport=true,…
  </code>
  .
</p>
<p>
  When the feature gate is enabled, you can set the
  <code>
    protocol
  </code>
  field of a Service, Endpoint, NetworkPolicy or Pod to
  <code>
    SCTP
  </code>
  . Kubernetes sets up the network accordingly for the SCTP associations, just like it does for TCP connections.
</p>
<h4 id="caveat-sctp-overview">
  Warnings
</h4>
<h5 id="caveat-sctp-multihomed">
  Support for multihomed SCTP associations
</h5>
<blockquote class="warning">
  <div>
    <strong>
      Warning:
    </strong>
    <p>
      The support of multihomed SCTP associations requires that the CNI plugin can support the assignment of multiple interfaces and IP addresses to a Pod.
    </p>
    <p>
      NAT for multihomed SCTP associations requires special logic in the corresponding kernel modules.
    </p>
  </div>
</blockquote>
<h5 id="caveat-sctp-loadbalancer-service-type">
  Service with type=LoadBalancer
</h5>
<blockquote class="warning">
  <div>
    <strong>
      Warning:
    </strong>
    You can only create a Service with
    <code>
      type
    </code>
    LoadBalancer plus
    <code>
      protocol
    </code>
    SCTP if the cloud provider&rsquo;s load balancer implementation supports SCTP as a protocol. Otherwise, the Service creation request is rejected. The current set of cloud load balancer providers (Azure, AWS, CloudStack, GCE, OpenStack) all lack support for SCTP.
  </div>
</blockquote>
<h5 id="caveat-sctp-windows-os">
  Windows
</h5>
<blockquote class="warning">
  <div>
    <strong>
      Warning:
    </strong>
    SCTP is not supported on Windows based nodes.
  </div>
</blockquote>
<h5 id="caveat-sctp-kube-proxy-userspace">
  Userspace kube-proxy
</h5>
<blockquote class="warning">
  <div>
    <strong>
      Warning:
    </strong>
    The kube-proxy does not support the management of SCTP associations when it is in userspace mode.
  </div>
</blockquote>
<h2 id="what-s-next">
  What&#39;s next
</h2>
<ul>
  <li>
    Read
    <a href="/docs/concepts/services-networking/connect-applications-service/">
      Connecting Applications with Services
    </a>
  </li>
  <li>
    Read about
    <a href="/docs/concepts/services-networking/ingress/">
      Ingress
    </a>
  </li>
  <li>
    Read about
    <a href="/docs/concepts/services-networking/endpoint-slices/">
      EndpointSlices
    </a>
  </li>
</ul>