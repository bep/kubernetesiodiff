<html><head></head><body>
<h1>
  Kubernetes API Concepts
</h1>
<p>
  <a href="https://github.com/kubernetes/website/edit/master/content/en/docs/reference/using-api/api-concepts.md" id="editPageButton" target="_blank">
    Edit This Page
  </a>
</p>
<h1>
  Kubernetes API Concepts
</h1>
<p>
  This page describes common concepts in the Kubernetes API.
</p>
<ul id="markdown-toc">
  <li>
    <a href="#standard-api-terminology">
      Standard API terminology
    </a>
  </li>
  <li>
    <a href="#efficient-detection-of-changes">
      Efficient detection of changes
    </a>
  </li>
  <li>
    <a href="#retrieving-large-results-sets-in-chunks">
      Retrieving large results sets in chunks
    </a>
  </li>
  <li>
    <a href="#receiving-resources-as-tables">
      Receiving resources as Tables
    </a>
  </li>
  <li>
    <a href="#alternate-representations-of-resources">
      Alternate representations of resources
    </a>
  </li>
  <li>
    <a href="#resource-deletion">
      Resource deletion
    </a>
  </li>
  <li>
    <a href="#single-resource-api">
      Single resource API
    </a>
  </li>
  <li>
    <a href="#dry-run">
      Dry-run
    </a>
  </li>
  <li>
    <a href="#server-side-apply">
      Server Side Apply
    </a>
  </li>
  <li>
    <a href="#resource-versions">
      Resource Versions
    </a>
  </li>
</ul>
<p>
  The Kubernetes API is a resource-based (RESTful) programmatic interface provided via HTTP. It supports retrieving, creating,
  updating, and deleting primary resources via the standard HTTP verbs (POST, PUT, PATCH, DELETE, GET), includes additional subresources for many objects that allow fine grained authorization (such as binding a pod to a node), and can accept and serve those resources in different representations for convenience or efficiency. It also supports efficient change notifications on resources via “watches” and consistent lists to allow other components to effectively cache and synchronize the state of resources.
</p>
<h2 id="standard-api-terminology">
  Standard API terminology
</h2>
<p>
  Most Kubernetes API resource types are
  <a href="/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects">
    objects
  </a>
  : they represent a concrete instance of a concept on the cluster, like a pod or namespace. A smaller number of API resource types are “virtual” - they often represent operations rather than objects, such as a permission check (use a POST with a JSON-encoded body of
  <code>
    SubjectAccessReview
  </code>
  to the
  <code>
    subjectaccessreviews
  </code>
  resource). All objects will have a unique name to allow idempotent creation and retrieval, but virtual resource types may not have unique names if they are not retrievable or do not rely on idempotency.
</p>
<p>
  Kubernetes generally leverages standard RESTful terminology to describe the API concepts:
</p>
<ul>
  <li>
    A
    <strong>
      resource type
    </strong>
    is the name used in the URL (
    <code>
      pods
    </code>
    ,
    <code>
      namespaces
    </code>
    ,
    <code>
      services
    </code>
    )
  </li>
  <li>
    All resource types have a concrete representation in JSON (their object schema) which is called a
    <strong>
      kind
    </strong>
  </li>
  <li>
    A list of instances of a resource type is known as a
    <strong>
      collection
    </strong>
  </li>
  <li>
    A single instance of the resource type is called a
    <strong>
      resource
    </strong>
  </li>
</ul>
<p>
  All resource types are either scoped by the cluster (
  <code>
    /apis/GROUP/VERSION/*
  </code>
  ) or to a namespace (
  <code>
    /apis/GROUP/VERSION/namespaces/NAMESPACE/*
  </code>
  ). A namespace-scoped resource type will be deleted when its namespace is deleted and access to that resource type is controlled by authorization checks on the namespace scope. The following paths are used to retrieve collections and resources:
</p>
<ul>
  <li>
    Cluster-scoped resources:
    <ul>
      <li>
        <code>
          GET /apis/GROUP/VERSION/RESOURCETYPE
        </code>
        - return the collection of resources of the resource type
      </li>
      <li>
        <code>
          GET /apis/GROUP/VERSION/RESOURCETYPE/NAME
        </code>
        - return the resource with NAME under the resource type
      </li>
    </ul>
  </li>
  <li>
    Namespace-scoped resources:
    <ul>
      <li>
        <code>
          GET /apis/GROUP/VERSION/RESOURCETYPE
        </code>
        - return the collection of all instances of the resource type across all namespaces
      </li>
      <li>
        <code>
          GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE
        </code>
        - return collection of all instances of the resource type in NAMESPACE
      </li>
      <li>
        <code>
          GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME
        </code>
        - return the instance of the resource type with NAME in NAMESPACE
      </li>
    </ul>
  </li>
</ul>
<p>
  Since a namespace is a cluster-scoped resource type, you can retrieve the list of all namespaces with
  <code>
    GET /api/v1/namespaces
  </code>
  and details about a particular namespace with
  <code>
    GET /api/v1/namespaces/NAME
  </code>
  .
</p>
<p>
  Almost all object resource types support the standard HTTP verbs - GET, POST, PUT, PATCH, and DELETE. Kubernetes uses the term
  <strong>
    list
  </strong>
  to describe returning a collection of resources to distinguish from retrieving a single resource which is usually called a
  <strong>
    get
  </strong>
  .
</p>
<p>
  Some resource types will have one or more sub-resources, represented as sub paths below the resource:
</p>
<ul>
  <li>
    Cluster-scoped subresource:
    <code>
      GET /apis/GROUP/VERSION/RESOURCETYPE/NAME/SUBRESOURCE
    </code>
  </li>
  <li>
    Namespace-scoped subresource:
    <code>
      GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME/SUBRESOURCE
    </code>
  </li>
</ul>
<p>
  The verbs supported for each subresource will differ depending on the object - see the API documentation more information. It is not possible to access sub-resources across multiple resources - generally a new virtual resource type would be used if that becomes necessary.
</p>
<h2 id="efficient-detection-of-changes">
  Efficient detection of changes
</h2>
<p>
  To enable clients to build a model of the current state of a cluster, all Kubernetes object resource types are required to support consistent lists and an incremental change notification feed called a
  <strong>
    watch
  </strong>
  .  Every Kubernetes object has a
  <code>
    resourceVersion
  </code>
  field representing the version of that resource as stored in the underlying database. When retrieving a collection of resources (either namespace or cluster scoped), the response from the server will contain a
  <code>
    resourceVersion
  </code>
  value that can be used to initiate a watch against the server. The server will return all changes (creates, deletes, and updates) that occur after the supplied
  <code>
    resourceVersion
  </code>
  . This allows a client to fetch the current state and then watch for changes without missing any updates. If the client watch is disconnected they can restart a new watch from the last returned
  <code>
    resourceVersion
  </code>
  , or perform a new collection request and begin again. See
  <a href="#resource-versions">
    Resource Version Semantics
  </a>
  for more detail.
</p>
<p>
  For example:
</p>
<ol>
  <li>
    <p>
      List all of the pods in a given namespace.
    </p>
    <pre><code> GET /api/v1/namespaces/test/pods
 ---
 200 OK
 Content-Type: application/json
 {
   &#34;kind&#34;: &#34;PodList&#34;,
   &#34;apiVersion&#34;: &#34;v1&#34;,
   &#34;metadata&#34;: {&#34;resourceVersion&#34;:&#34;10245&#34;},
   &#34;items&#34;: [...]
 }</code></pre>
  </li>
  <li>
    <p>
      Starting from resource version 10245, receive notifications of any creates, deletes, or updates as individual JSON objects.
    </p>
    <pre><code> GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245
 ---
 200 OK
 Transfer-Encoding: chunked
 Content-Type: application/json
 {
   &#34;type&#34;: &#34;ADDED&#34;,
   &#34;object&#34;: {&#34;kind&#34;: &#34;Pod&#34;, &#34;apiVersion&#34;: &#34;v1&#34;, &#34;metadata&#34;: {&#34;resourceVersion&#34;: &#34;10596&#34;, ...}, ...}
 }
 {
   &#34;type&#34;: &#34;MODIFIED&#34;,
   &#34;object&#34;: {&#34;kind&#34;: &#34;Pod&#34;, &#34;apiVersion&#34;: &#34;v1&#34;, &#34;metadata&#34;: {&#34;resourceVersion&#34;: &#34;11020&#34;, ...}, ...}
 }
 ...</code></pre>
  </li>
</ol>
<p>
  A given Kubernetes server will only preserve a historical list of changes for a limited time. Clusters using etcd3 preserve changes in the last 5 minutes by default.  When the requested watch operations fail because the historical version of that resource is not available, clients must handle the case by recognizing the status code
  <code>
    410 Gone
  </code>
  , clearing their local cache, performing a list operation, and starting the watch from the
  <code>
    resourceVersion
  </code>
  returned by that new list operation. Most client libraries offer some form of standard tool for this logic. (In Go this is called a
  <code>
    Reflector
  </code>
  and is located in the
  <code>
    k8s.io/client-go/cache
  </code>
  package.)
</p>
<h3 id="watch-bookmarks">
  Watch bookmarks
</h3>
<p>
  To mitigate the impact of short history window, we introduced a concept of
  <code>
    bookmark
  </code>
  watch event. It is a special kind of event to mark that all changes up to a given
  <code>
    resourceVersion
  </code>
  the client is requesting have already been sent. Object returned in that event is of the type requested by the request, but only
  <code>
    resourceVersion
  </code>
  field is set, e.g.:
</p>
<pre><code>    GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245&amp;allowWatchBookmarks=true
    ---
    200 OK
    Transfer-Encoding: chunked
    Content-Type: application/json
    {
      &#34;type&#34;: &#34;ADDED&#34;,
      &#34;object&#34;: {&#34;kind&#34;: &#34;Pod&#34;, &#34;apiVersion&#34;: &#34;v1&#34;, &#34;metadata&#34;: {&#34;resourceVersion&#34;: &#34;10596&#34;, ...}, ...}
    }
    ...
    {
      &#34;type&#34;: &#34;BOOKMARK&#34;,
      &#34;object&#34;: {&#34;kind&#34;: &#34;Pod&#34;, &#34;apiVersion&#34;: &#34;v1&#34;, &#34;metadata&#34;: {&#34;resourceVersion&#34;: &#34;12746&#34;} }
    }</code></pre>
<p>
  <code>
    Bookmark
  </code>
  events can be requested by
  <code>
    allowWatchBookmarks=true
  </code>
  option in watch requests, but clients shouldn’t assume bookmarks are returned at any specific interval, nor may they assume the server will send any
  <code>
    bookmark
  </code>
  event.
</p>
<h2 id="retrieving-large-results-sets-in-chunks">
  Retrieving large results sets in chunks
</h2>
<p>
  On large clusters, retrieving the collection of some resource types may result in very large responses that can impact the server and client. For instance, a cluster may have tens of thousands of pods, each of which is 1-2kb of encoded JSON. Retrieving all pods across all namespaces may result in a very large response (10-20MB) and consume a large amount of server resources. Starting in Kubernetes 1.9 the server supports the ability to break a single large collection request into many smaller chunks while preserving the consistency of the total request. Each chunk can be returned sequentially which reduces both the total size of the request and allows user-oriented clients to display results incrementally to improve responsiveness.
</p>
<p>
  To retrieve a single list in chunks, two new parameters
  <code>
    limit
  </code>
  and
  <code>
    continue
  </code>
  are supported on collection requests and a new field
  <code>
    continue
  </code>
  is returned from all list operations in the list
  <code>
    metadata
  </code>
  field. A client should specify the maximum results they wish to receive in each chunk with
  <code>
    limit
  </code>
  and the server will return up to
  <code>
    limit
  </code>
  resources in the result and include a
  <code>
    continue
  </code>
  value if there are more resources in the collection. The client can then pass this
  <code>
    continue
  </code>
  value to the server on the next request to instruct the server to return the next chunk of results. By continuing until the server returns an empty
  <code>
    continue
  </code>
  value the client can consume the full set of results.
</p>
<p>
  Like a watch operation, a
  <code>
    continue
  </code>
  token will expire after a short amount of time (by default 5 minutes) and return a
  <code>
    410 Gone
  </code>
  if more results cannot be returned. In this case, the client will need to start from the beginning or omit the
  <code>
    limit
  </code>
  parameter.
</p>
<p>
  For example, if there are 1,253 pods on the cluster and the client wants to receive chunks of 500 pods at a time, they would request those chunks as follows:
</p>
<ol>
  <li>
    <p>
      List all of the pods on a cluster, retrieving up to 500 pods each time.
    </p>
    <pre><code> GET /api/v1/pods?limit=500
 ---
 200 OK
 Content-Type: application/json
 {
   &#34;kind&#34;: &#34;PodList&#34;,
   &#34;apiVersion&#34;: &#34;v1&#34;,
   &#34;metadata&#34;: {
     &#34;resourceVersion&#34;:&#34;10245&#34;,
     &#34;continue&#34;: &#34;ENCODED_CONTINUE_TOKEN&#34;,
     ...
   },
   &#34;items&#34;: [...] // returns pods 1-500
 }</code></pre>
  </li>
  <li>
    <p>
      Continue the previous call, retrieving the next set of 500 pods.
    </p>
    <pre><code> GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN
 ---
 200 OK
 Content-Type: application/json
 {
   &#34;kind&#34;: &#34;PodList&#34;,
   &#34;apiVersion&#34;: &#34;v1&#34;,
   &#34;metadata&#34;: {
     &#34;resourceVersion&#34;:&#34;10245&#34;,
     &#34;continue&#34;: &#34;ENCODED_CONTINUE_TOKEN_2&#34;,
     ...
   },
   &#34;items&#34;: [...] // returns pods 501-1000
 }</code></pre>
  </li>
  <li>
    <p>
      Continue the previous call, retrieving the last 253 pods.
    </p>
    <pre><code> GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN_2
 ---
 200 OK
 Content-Type: application/json
 {
   &#34;kind&#34;: &#34;PodList&#34;,
   &#34;apiVersion&#34;: &#34;v1&#34;,
   &#34;metadata&#34;: {
     &#34;resourceVersion&#34;:&#34;10245&#34;,
     &#34;continue&#34;: &#34;&#34;, // continue token is empty because we have reached the end of the list
     ...
   },
   &#34;items&#34;: [...] // returns pods 1001-1253
 }</code></pre>
  </li>
</ol>
<p>
  Note that the
  <code>
    resourceVersion
  </code>
  of the list remains constant across each request, indicating the server is showing us a consistent snapshot of the pods. Pods that are created, updated, or deleted after version
  <code>
    10245
  </code>
  would not be shown unless the user makes a list request without the
  <code>
    continue
  </code>
  token.  This allows clients to break large requests into smaller chunks and then perform a watch operation on the full set without missing any updates.
</p>
<h2 id="receiving-resources-as-tables">
  Receiving resources as Tables
</h2>
<p>
  <code>
    kubectl get
  </code>
  is a simple tabular representation of one or more instances of a particular resource type. In the past, clients were required to reproduce the tabular and describe output implemented in
  <code>
    kubectl
  </code>
  to perform simple lists of objects.
  A few limitations of that approach include non-trivial logic when dealing with certain objects. Additionally, types provided by API aggregation or third party resources are not known at compile time. This means that generic implementations had to be in place for types unrecognized by a client.
</p>
<p>
  In order to avoid potential limitations as described above, clients may request the Table representation of objects, delegating specific details of printing to the server. The Kubernetes API implements standard HTTP content type negotiation: passing an
  <code>
    Accept
  </code>
  header containing a value of
  <code>
    application/json;as=Table;g=meta.k8s.io;v=v1beta1
  </code>
  with a
  <code>
    GET
  </code>
  call will request that the server return objects in the Table content type.
</p>
<p>
  For example:
</p>
<ol>
  <li>
    <p>
      List all of the pods on a cluster in the Table format.
    </p>
    <pre><code> GET /api/v1/pods
 Accept: application/json;as=Table;g=meta.k8s.io;v=v1beta1
 ---
 200 OK
 Content-Type: application/json
 {
     &#34;kind&#34;: &#34;Table&#34;,
     &#34;apiVersion&#34;: &#34;meta.k8s.io/v1beta1&#34;,
     ...
     &#34;columnDefinitions&#34;: [
         ...
     ]
 }</code></pre>
  </li>
</ol>
<p>
  For API resource types that do not have a custom Table definition on the server, a default Table response is returned by the server, consisting of the resource’s
  <code>
    name
  </code>
  and
  <code>
    creationTimestamp
  </code>
  fields.
</p>
<pre><code>    GET /apis/crd.example.com/v1alpha1/namespaces/default/resources
    ---
    200 OK
    Content-Type: application/json
    ...
    {
        &#34;kind&#34;: &#34;Table&#34;,
        &#34;apiVersion&#34;: &#34;meta.k8s.io/v1beta1&#34;,
        ...
        &#34;columnDefinitions&#34;: [
            {
                &#34;name&#34;: &#34;Name&#34;,
                &#34;type&#34;: &#34;string&#34;,
                ...
            },
            {
                &#34;name&#34;: &#34;Created At&#34;,
                &#34;type&#34;: &#34;date&#34;,
                ...
            }
        ]
    }</code></pre>
<p>
  Table responses are available beginning in version 1.10 of the kube-apiserver. As such, not all API resource types will support a Table response, specifically when using a client against older clusters. Clients that must work against all resource types, or can potentially deal with older clusters, should specify multiple content types in their
  <code>
    Accept
  </code>
  header to support fallback to non-Tabular JSON:
</p>
<pre><code>Accept: application/json;as=Table;g=meta.k8s.io;v=v1beta1, application/json</code></pre>
<h2 id="alternate-representations-of-resources">
  Alternate representations of resources
</h2>
<p>
  By default Kubernetes returns objects serialized to JSON with content type
  <code>
    application/json
  </code>
  . This is the default serialization format for the API. However, clients may request the more efficient Protobuf representation of these objects for better performance at scale. The Kubernetes API implements standard HTTP content type negotiation: passing an
  <code>
    Accept
  </code>
  header with a
  <code>
    GET
  </code>
  call will request that the server return objects in the provided content type, while sending an object in Protobuf to the server for a
  <code>
    PUT
  </code>
  or
  <code>
    POST
  </code>
  call takes the
  <code>
    Content-Type
  </code>
  header. The server will return a
  <code>
    Content-Type
  </code>
  header if the requested format is supported, or the
  <code>
    406 Not acceptable
  </code>
  error if an invalid content type is provided.
</p>
<p>
  See the API documentation for a list of supported content types for each API.
</p>
<p>
  For example:
</p>
<ol>
  <li>
    <p>
      List all of the pods on a cluster in Protobuf format.
    </p>
    <pre><code> GET /api/v1/pods
 Accept: application/vnd.kubernetes.protobuf
 ---
 200 OK
 Content-Type: application/vnd.kubernetes.protobuf
 ... binary encoded PodList object</code></pre>
  </li>
  <li>
    <p>
      Create a pod by sending Protobuf encoded data to the server, but request a response in JSON.
    </p>
    <pre><code> POST /api/v1/namespaces/test/pods
 Content-Type: application/vnd.kubernetes.protobuf
 Accept: application/json
 ... binary encoded Pod object
 ---
 200 OK
 Content-Type: application/json
 {
   &#34;kind&#34;: &#34;Pod&#34;,
   &#34;apiVersion&#34;: &#34;v1&#34;,
   ...
 }</code></pre>
  </li>
</ol>
<p>
  Not all API resource types will support Protobuf, specifically those defined via Custom Resource Definitions or those that are API extensions. Clients that must work against all resource types should specify multiple content types in their
  <code>
    Accept
  </code>
  header to support fallback to JSON:
</p>
<pre><code>Accept: application/vnd.kubernetes.protobuf, application/json</code></pre>
<h3 id="protobuf-encoding">
  Protobuf encoding
</h3>
<p>
  Kubernetes uses an envelope wrapper to encode Protobuf responses. That wrapper starts with a 4 byte magic number to help identify content in disk or in etcd as Protobuf (as opposed to JSON), and then is followed by a Protobuf encoded wrapper message, which describes the encoding and type of the underlying object and then contains the object.
</p>
<p>
  The wrapper format is:
</p>
<pre><code>A four byte magic number prefix:
  Bytes 0-3: &#34;k8s\x00&#34; [0x6b, 0x38, 0x73, 0x00]

An encoded Protobuf message with the following IDL:
  message Unknown {
    // typeMeta should have the string values for &#34;kind&#34; and &#34;apiVersion&#34; as set on the JSON object
    optional TypeMeta typeMeta = 1;

    // raw will hold the complete serialized object in protobuf. See the protobuf definitions in the client libraries for a given kind.
    optional bytes raw = 2;

    // contentEncoding is encoding used for the raw data. Unspecified means no encoding.
    optional string contentEncoding = 3;

    // contentType is the serialization method used to serialize &#39;raw&#39;. Unspecified means application/vnd.kubernetes.protobuf and is usually
    // omitted.
    optional string contentType = 4;
  }

  message TypeMeta {
    // apiVersion is the group/version for this type
    optional string apiVersion = 1;
    // kind is the name of the object schema. A protobuf definition should exist for this object.
    optional string kind = 2;
  }</code></pre>
<p>
  Clients that receive a response in
  <code>
    application/vnd.kubernetes.protobuf
  </code>
  that does not match the expected prefix should reject the response, as future versions may need to alter the serialization format in an incompatible way and will do so by changing the prefix.
</p>
<h2 id="resource-deletion">
  Resource deletion
</h2>
<p>
  Resources are deleted in two phases: 1) finalization, and 2) removal.
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">{
  <span style="color:#b44">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ConfigMap&#34;</span>,
  <span style="color:#b44">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;v1&#34;</span>,
  <span style="color:#b44">&#34;metadata&#34;</span>: {
    <span style="color:#b44">&#34;finalizers&#34;</span>: {<span style="color:#b44">&#34;url.io/neat-finalization&#34;</span>, <span style="color:#b44">&#34;other-url.io/my-finalizer&#34;</span>},
    <span style="color:#b44">&#34;deletionTimestamp&#34;</span>: <span style="color:#a2f;font-weight:bold">nil</span>,
  }
}</code></pre>
</div>
<p>
  When a client first deletes a resource, the
  <code>
    .metadata.deletionTimestamp
  </code>
  is set to the current time.
  Once the
  <code>
    .metadata.deletionTimestamp
  </code>
  is set, external controllers that act on finalizers
  may start performing their cleanup work at any time, in any order.
  Order is NOT enforced because it introduces significant risk of stuck
  <code>
    .metadata.finalizers
  </code>
  .
  <code>
    .metadata.finalizers
  </code>
  is a shared field, any actor with permission can reorder it.
  If the finalizer list is processed in order, then this can lead to a situation
  in which the component responsible for the first finalizer in the list is
  waiting for a signal (field value, external system, or other) produced by a
  component responsible for a finalizer later in the list, resulting in a deadlock.
  Without enforced ordering finalizers are free to order amongst themselves and
  are not vulnerable to ordering changes in the list.
</p>
<p>
  Once the last finalizer is removed, the resource is actually removed from etcd.
</p>
<h2 id="single-resource-api">
  Single resource API
</h2>
<p>
  API verbs GET, CREATE, UPDATE, PATCH, DELETE and PROXY support single resources only.
  These verbs with single resource support have no support for submitting
  multiple resources together in an ordered or unordered list or transaction.
  Clients including kubectl will parse a list of resources and make
  single-resource API requests.
</p>
<p>
  API verbs LIST and WATCH support getting multiple resources, and
  DELETECOLLECTION supports deleting multiple resources.
</p>
<h2 id="dry-run">
  Dry-run
</h2>
<div style="margin-top: 10px; margin-bottom: 10px;">
<p data-diff="">
  <b>
    FEATURE STATE:
  </b>
  <code>
    Kubernetes v1.18
  </code>
</p>
<p>
  <a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all">
    <span class="ui-icon ui-icon-newwin"></span>
    stable
  </a>
</p>
<div id="feature-state-dialog" class="ui-dialog-content" title="stable">
  <p>
    This feature is
    <em>
      stable
    </em>
    , meaning:
  </p>
  <ul>
    <li>
      The version name is vX where X is an integer.
    </li>
    <li>
      Stable versions of features will appear in released software for many subsequent versions.
    </li>
  </ul>
</div>
<script>
  $(function(){
  <pre><code>$( &quot;#feature-state-dialog&quot; ).dialog({
  autoOpen: false,
  width: &quot;600&quot;,
  buttons: [
  {
  text: &quot;Ok&quot;,
  click: function() {
  $( this ).dialog( &quot;close&quot; );
  }
  }
  ]
  });


  $( &quot;#feature-state-dialog-link&quot; ).click(function( event ) {
  $( &quot;#feature-state-dialog&quot; ).dialog( &quot;open&quot; );
  event.preventDefault();
  });</code></pre>
  <p>});
</script>
<p>
  The modifying verbs (
  <code>
    POST
  </code>
  ,
  <code>
    PUT
  </code>
  ,
  <code>
    PATCH
  </code>
  , and
  <code>
    DELETE
  </code>
  ) can accept requests in a
  <em>
    dry run
  </em>
  mode. Dry run mode helps to evaluate a request through the typical request stages (admission chain, validation, merge conflicts) up until persisting objects to storage. The response body for the request is as close as possible to a non-dry-run response. The system guarantees that dry-run requests will not be persisted in storage or have any other side effects.
</p>
<h3 id="make-a-dry-run-request">
  Make a dry-run request
</h3>
<p>
  Dry-run is triggered by setting the
  <code>
    dryRun
  </code>
  query parameter. This parameter is a string, working as an enum, and the only accepted values are:
</p>
<ul>
  <li>
    <code>
      All
    </code>
    : Every stage runs as normal, except for the final storage stage. Admission controllers are run to check that the request is valid, mutating controllers mutate the request, merge is performed on
    <code>
      PATCH
    </code>
    , fields are defaulted, and schema validation occurs. The changes are not persisted to the underlying storage, but the final object which would have been persisted is still returned to the user, along with the normal status code. If the request would trigger an admission controller which would have side effects, the request will be failed rather than risk an unwanted side effect. All built in admission control plugins support dry-run. Additionally, admission webhooks can declare in their
    <a href="/docs/reference/generated/kubernetes-api/v1.13/#webhook-v1beta1-admissionregistration-k8s-io">
      configuration object
    </a>
    that they do not have side effects by setting the sideEffects field to “None”. If a webhook actually does have side effects, then the sideEffects field should be set to “NoneOnDryRun”, and the webhook should also be modified to understand the
    <code>
      DryRun
    </code>
    field in AdmissionReview, and prevent side effects on dry-run requests.
  </li>
  <li>
    Leave the value empty, which is also the default: Keep the default modifying behavior.
  </li>
</ul>
<p>
  For example:
</p><pre><code>    POST /api/v1/namespaces/test/pods?dryRun=All
    Content-Type: application/json
    Accept: application/json</code></pre>
<p>
  The response would look the same as for non-dry-run request, but the values of some generated fields may differ.
</p>
<h3 id="dry-run-authorization">
  Dry-run authorization
</h3>
<p>
  Authorization for dry-run and non-dry-run requests is identical. Thus, to make
  a dry-run request, the user must be authorized to make the non-dry-run request.
</p>
<p>
  For example, to run a dry-run
  <code>
    PATCH
  </code>
  for Deployments, you must have the
  <code>
    PATCH
  </code>
  permission for Deployments, as in the example of the RBAC rule below.
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#a2f;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#a2f;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;extensions&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;apps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;deployments&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;patch&#34;</span>]<span style="color:#bbb">
</span></code></pre>
</div>
<p>
  See
  <a href="/docs/reference/access-authn-authz/authorization/">
    Authorization Overview
  </a>
  .
</p>
<h3 id="generated-values">
  Generated values
</h3>
<p>
  Some values of an object are typically generated before the object is persisted. It is important not to rely upon the values of these fields set by a dry-run request, since these values will likely be different in dry-run mode from when the real request is made. Some of these fields are:
</p>
<ul>
  <li>
    <code>
      name
    </code>
    : if
    <code>
      generateName
    </code>
    is set,
    <code>
      name
    </code>
    will have a unique random name
  </li>
  <li>
    <code>
      creationTimestamp
    </code>
    /
    <code>
      deletionTimestamp
    </code>
    : records the time of creation/deletion
  </li>
  <li>
    <code>
      UID
    </code>
    : uniquely identifies the object and is randomly generated (non-deterministic)
  </li>
  <li>
    <code>
      resourceVersion
    </code>
    : tracks the persisted version of the object
  </li>
  <li>
    Any field set by a mutating admission controller
  </li>
  <li>
    For the
    <code>
      Service
    </code>
    resource: Ports or IPs that kube-apiserver assigns to v1.Service objects
  </li>
</ul>
<h2 id="server-side-apply">
  Server Side Apply
</h2>
<div style="margin-top: 10px; margin-bottom: 10px;">
<p>
  <b>
    FEATURE STATE:
  </b>
  <code>
    Kubernetes v1.16
  </code>
</p>
<p>
  <a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all">
    <span class="ui-icon ui-icon-newwin"></span>
    beta
  </a>
</p>
<div id="feature-state-dialog" class="ui-dialog-content" title="beta">
  <p>
    This feature is currently in a
    <em>
      beta
    </em>
    state, meaning:
  </p>
  <ul>
    <li>
      The version names contain beta (e.g. v2beta3).
    </li>
    <li>
      Code is well tested. Enabling the feature is considered safe. Enabled by default.
    </li>
    <li>
      Support for the overall feature will not be dropped, though details may change.
    </li>
    <li>
      The schema and/or semantics of objects may change in incompatible ways in a subsequent beta or stable release. When this happens, we will provide instructions for migrating to the next version. This may require deleting, editing, and re-creating API objects. The editing process may require some thought. This may require downtime for applications that rely on the feature.
    </li>
    <li>
      Recommended for only non-business-critical uses because of potential for incompatible changes in subsequent releases. If you have multiple clusters that can be upgraded independently, you may be able to relax this restriction.
    </li>
    <li>
      <strong>
        Please do try our beta features and give feedback on them! After they exit beta, it may not be practical for us to make more changes.
      </strong>
    </li>
  </ul>
</div>
<script>
  $(function(){
  <pre><code>$( &quot;#feature-state-dialog&quot; ).dialog({
  autoOpen: false,
  width: &quot;600&quot;,
  buttons: [
  {
  text: &quot;Ok&quot;,
  click: function() {
  $( this ).dialog( &quot;close&quot; );
  }
  }
  ]
  });


  $( &quot;#feature-state-dialog-link&quot; ).click(function( event ) {
  $( &quot;#feature-state-dialog&quot; ).dialog( &quot;open&quot; );
  event.preventDefault();
  });</code></pre>
  <p>});
</script>
<blockquote class="note">
  <div>
    <strong>
      Note:
    </strong>
    Starting from Kubernetes v1.18, if you have Server Side Apply enabled then the control plane tracks managed fields for all newly created objects.
  </div>
</blockquote>
<h3 id="introduction">
  Introduction
</h3>
<p>
  Server Side Apply helps users and controllers manage their resources via
  declarative configurations. It allows them to create and/or modify their
  objects declaratively, simply by sending their fully specified intent.
</p>
<p>
  A fully specified intent is a partial object that only includes the fields and
  values for which the user has an opinion. That intent either creates a new
  object or is
  <a href="#merge-strategy">
    combined
  </a>
  , by the server, with the existing object.
</p>
<p>
  The system supports multiple appliers collaborating on a single object.
</p>
<p>
  This model of specifying intent makes it difficult to remove existing fields.
  When a field is removed from one’s config and applied, the value will be kept
  (the system assumes that you don’t care about that value anymore). If an item is
  removed from a list or a map, it will be removed if no other appliers care about
  its presence.
</p>
<p>
  Changes to an object’s fields are tracked through a “
  <a href="#field-management">
    field management
  </a>
  ”
  mechanism. When a field’s value changes, ownership moves from its current
  manager to the manager making the change. When trying to apply an object, fields
  that have a different value and are owned by another manager will result in a
  <a href="#conflicts">
    conflict
  </a>
  . This is done in order to signal that the operation might undo another
  collaborator’s changes. Conflicts can be forced, in which case the value will be
  overridden, and the ownership will be transferred.
</p>
<p>
  It is meant both as a replacement for the original
  <code>
    kubectl apply
  </code>
  and as a
  simpler mechanism to write controllers.
</p>
<h3 id="field-management">
  Field Management
</h3>
<p>
  Compared to the
  <code>
    last-applied
  </code>
  annotation managed by
  <code>
    kubectl
  </code>
  , Server Side
  Apply uses a more declarative approach, which tracks a user’s field management,
  rather than a user’s last applied state. This means that as a side effect of
  using Server Side Apply, information about which field manager manages each
  field in an object also becomes available.
</p>
<p>
  For a user to manage a field, in the Server Side Apply sense, means that the
  user relies on and expects the value of the field not to change. The user who
  last made an assertion about the value of a field will be recorded as the
  current field manager. This can be done either by changing the value with
  <code>
    POST
  </code>
  ,
  <code>
    PUT
  </code>
  , or non-apply
  <code>
    PATCH
  </code>
  , or by including the field in a config sent
  to the Server Side Apply endpoint. When using Server-Side Apply, trying to
  change a field which is managed by someone else will result in a rejected
  request (if not forced, see
  <a href="#conflicts">
    Conflicts
  </a>
  ).
</p>
<p>
  Field management is stored in a newly introduced
  <code>
    managedFields
  </code>
  field that is
  part of an object’s
  <a href="/docs/reference/generated/kubernetes-api/v1.16/#objectmeta-v1-meta">
    <code>
      metadata
    </code>
  </a>
  .
</p>
<p>
  A simple example of an object created by Server Side Apply could look like this:
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#a2f;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ConfigMap<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>test-cm<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">test-label</span>:<span style="color:#bbb"> </span>test<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">managedFields</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#a2f;font-weight:bold">manager</span>:<span style="color:#bbb"> </span>kubectl<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">operation</span>:<span style="color:#bbb"> </span>Apply<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">time</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2010-10-10T0:00:00Z&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">fieldsType</span>:<span style="color:#bbb"> </span>FieldsV1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">fieldsV1</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">f:metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">f:labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#a2f;font-weight:bold">f:test-label</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">f:data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">f:key</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">key</span>:<span style="color:#bbb"> </span>some<span style="color:#bbb"> </span>value<span style="color:#bbb">
</span></code></pre>
</div>
<p>
  The above object contains a single manager in
  <code>
    metadata.managedFields
  </code>
  . The
  manager consists of basic information about the managing entity itself, like
  operation type, api version, and the fields managed by it.
</p>
<blockquote class="note">
  <div>
    <strong>
      Note:
    </strong>
    This field is managed by the apiserver and should not be changed by
    the user.
  </div>
</blockquote>
<p>
  Nevertheless it is possible to change
  <code>
    metadata.managedFields
  </code>
  through an
  <code>
    Update
  </code>
  operation. Doing so is highly discouraged, but might be a reasonable
  option to try if, for example, the
  <code>
    managedFields
  </code>
  get into an inconsistent
  state (which clearly should not happen).
</p>
<p>
  The format of the
  <code>
    managedFields
  </code>
  is described in the
  <a href="/docs/reference/generated/kubernetes-api/v1.16/#fieldsv1-v1-meta">
    API
  </a>
  .
</p>
<h3 id="conflicts">
  Conflicts
</h3>
<p>
  A conflict is a special status error that occurs when an
  <code>
    Apply
  </code>
  operation tries
  to change a field, which another user also claims to manage. This prevents an
  applier from unintentionally overwriting the value set by another user. When
  this occurs, the applier has 3 options to resolve the conflicts:
</p>
<ul>
  <li>
    <strong>
      Overwrite value, become sole manager:
    </strong>
    If overwriting the value was
    intentional (or if the applier is an automated process like a controller) the
    applier should set the
    <code>
      force
    </code>
    query parameter to true and make the request
    again. This forces the operation to succeed, changes the value of the field,
    and removes the field from all other managers’ entries in managedFields.
  </li>
  <li>
    <strong>
      Don’t overwrite value, give up management claim:
    </strong>
    If the applier doesn’t
    care about the value of the field anymore, they can remove it from their
    config and make the request again. This leaves the value unchanged, and causes
    the field to be removed from the applier’s entry in managedFields.
  </li>
  <li>
    <strong>
      Don’t overwrite value, become shared manager:
    </strong>
    If the applier still cares
    about the value of the field, but doesn’t want to overwrite it, they can
    change the value of the field in their config to match the value of the object
    on the server, and make the request again. This leaves the value unchanged,
    and causes the field’s management to be shared by the applier and all other
    field managers that already claimed to manage it.
  </li>
</ul>
<h3 id="managers">
  Managers
</h3>
<p>
  Managers identify distinct workflows that are modifying the object (especially
  useful on conflicts!), and can be specified through the
  <code>
    fieldManager
  </code>
  query
  parameter as part of a modifying request. It is required for the apply endpoint,
  though kubectl will default it to
  <code>
    kubectl
  </code>
  . For other updates, its default is
  computed from the user-agent.
</p>
<h3 id="apply-and-update">
  Apply and Update
</h3>
<p>
  The two operation types considered by this feature are
  <code>
    Apply
  </code>
  (
  <code>
    PATCH
  </code>
  with
  content type
  <code>
    application/apply-patch+yaml
  </code>
  ) and
  <code>
    Update
  </code>
  (all other operations
  which modify the object). Both operations update the
  <code>
    managedFields
  </code>
  , but behave
  a little differently.
</p>
<blockquote class="note">
  <div>
    <strong>
      Note:
    </strong>
    <p>
      Whether you are submitting JSON data or YAML data, use
      <code>
        application/apply-patch+yaml
      </code>
      as the
      Content-Type header value.
    </p>
    <p>
      All JSON documents are valid YAML.
    </p>
  </div>
</blockquote>
<p>
  For instance, only the apply operation fails on conflicts while update does
  not. Also, apply operations are required to identify themselves by providing a
  <code>
    fieldManager
  </code>
  query parameter, while the query parameter is optional for update
  operations. Finally, when using the apply operation you cannot have
  <code>
    managedFields
  </code>
  in the object that is being applied.
</p>
<p>
  An example object with multiple managers could look like this:
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#a2f;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ConfigMap<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">name</span>:<span style="color:#bbb"> </span>test-cm<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">test-label</span>:<span style="color:#bbb"> </span>test<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">managedFields</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#a2f;font-weight:bold">manager</span>:<span style="color:#bbb"> </span>kubectl<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">operation</span>:<span style="color:#bbb"> </span>Apply<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">fields</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">f:metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">f:labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#a2f;font-weight:bold">f:test-label</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#a2f;font-weight:bold">manager</span>:<span style="color:#bbb"> </span>kube-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">operation</span>:<span style="color:#bbb"> </span>Update<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">time</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;2019-03-30T16:00:00.000Z&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#a2f;font-weight:bold">fields</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#a2f;font-weight:bold">f:data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#a2f;font-weight:bold">f:key</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#a2f;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#a2f;font-weight:bold">key</span>:<span style="color:#bbb"> </span>new<span style="color:#bbb"> </span>value<span style="color:#bbb">
</span></code></pre>
</div>
<p>
  In this example, a second operation was run as an
  <code>
    Update
  </code>
  by the manager called
  <code>
    kube-controller-manager
  </code>
  . The update changed a value in the data field which
  caused the field’s management to change to the
  <code>
    kube-controller-manager
  </code>
  .
</p>
<blockquote class="note">
  <div>
    <strong>
      Note:
    </strong>
    If this update would have been an
    <code>
      Apply
    </code>
    operation, the operation
    would have failed due to conflicting ownership.
  </div>
</blockquote>
<h3 id="merge-strategy">
  Merge strategy
</h3>
<p>
  The merging strategy, implemented with Server Side Apply, provides a generally
  more stable object lifecycle. Server Side Apply tries to merge fields based on
  the fact who manages them instead of overruling just based on values. This way
  it is intended to make it easier and more stable for multiple actors updating
  the same object by causing less unexpected interference.
</p>
<p>
  When a user sends a “fully-specified intent” object to the Server Side Apply
  endpoint, the server merges it with the live object favoring the value in the
  applied config if it is specified in both places. If the set of items present in
  the applied config is not a superset of the items applied by the same user last
  time, each missing item not managed by any other appliers is removed. For
  more information about how an object’s schema is used to make decisions when
  merging, see
  <a href="https://sigs.k8s.io/structured-merge-diff">
    sigs.k8s.io/structured-merge-diff
  </a>
  .
</p>
<p>
  A number of markers were added in Kubernetes 1.16 and 1.17, to allow API developers to describe the merge strategy supported by lists, maps, and structs. These markers can be applied to objects of the respective type, in Go files or OpenAPI specs.
</p>
<table>
  <thead>
    <tr>
      <th>
        Golang marker
      </th>
      <th>
        OpenAPI extension
      </th>
      <th>
        Accepted values
      </th>
      <th>
        Description
      </th>
      <th>
        Introduced in
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <code>
          //+listType
        </code>
      </td>
      <td>
        <code>
          x-kubernetes-list-type
        </code>
      </td>
      <td>
        <code>
          atomic
        </code>
        /
        <code>
          set
        </code>
        /
        <code>
          map
        </code>
      </td>
      <td>
        Applicable to lists.
        <code>
          atomic
        </code>
        and
        <code>
          set
        </code>
        apply to lists with scalar elements only.
        <code>
          map
        </code>
        applies to lists of nested types only. If configured as
        <code>
          atomic
        </code>
        , the entire list is replaced during merge; a single manager manages the list as a whole at any one time. If
        <code>
          granular
        </code>
        , different managers can manage entries separately.
      </td>
      <td>
        1.16
      </td>
    </tr>
    <tr>
      <td>
        <code>
          //+listMapKeys
        </code>
      </td>
      <td>
        <code>
          x-kubernetes-list-map-keys
        </code>
      </td>
      <td>
        Slice of map keys that uniquely identify entries for example
        <code>
          [&#34;port&#34;, &#34;protocol&#34;]
        </code>
      </td>
      <td>
        Only applicable when
        <code>
          +listType=map
        </code>
        . A slice of strings whose values in combination must uniquely identify list entries.
      </td>
      <td>
        1.16
      </td>
    </tr>
    <tr>
      <td>
        <code>
          //+mapType
        </code>
      </td>
      <td>
        <code>
          x-kubernetes-map-type
        </code>
      </td>
      <td>
        <code>
          atomic
        </code>
        /
        <code>
          granular
        </code>
      </td>
      <td>
        Applicable to maps.
        <code>
          atomic
        </code>
        means that the map can only be entirely replaced by a single manager.
        <code>
          granular
        </code>
        means that the map supports separate managers updating individual fields.
      </td>
      <td>
        1.17
      </td>
    </tr>
    <tr>
      <td>
        <code>
          //+structType
        </code>
      </td>
      <td>
        <code>
          x-kubernetes-map-type
        </code>
      </td>
      <td>
        <code>
          atomic
        </code>
        /
        <code>
          granular
        </code>
      </td>
      <td>
        Applicable to structs; otherwise same usage and OpenAPI annotation as
        <code>
          //+mapType
        </code>
        .
      </td>
      <td>
        1.17
      </td>
    </tr>
  </tbody>
</table>
<h3 id="custom-resources">
  Custom Resources
</h3>
<p>
  By default, Server Side Apply treats custom resources as unstructured data. All
  keys are treated the same as struct fields, and all lists are considered atomic.
  If the validation field is specified in the Custom Resource Definition, it is
  used when merging objects of this type.
</p>
<h3 id="using-server-side-apply-in-a-controller">
  Using Server-Side Apply in a controller
</h3>
<p>
  As a developer of a controller, you can use server-side apply as a way to
  simplify the update logic of your controller. The main differences with a
  read-modify-write and/or patch are the following:
</p>
<ul>
  <li>
    the applied object must contain all the fields that the controller cares about.
  </li>
  <li>
    there are no way to remove fields that haven’t been applied by the controller
    before (controller can still send a PATCH/UPDATE for these use-cases).
  </li>
  <li>
    the object doesn’t have to be read beforehand,
    <code>
      resourceVersion
    </code>
    doesn’t have
    to be specified.
  </li>
</ul>
<p>
  It is strongly recommended for controllers to always “force” conflicts, since they
  might not be able to resolve or act on these conflicts.
</p>
<h3 id="comparison-with-client-side-apply">
  Comparison with Client Side Apply
</h3>
<p>
  A consequence of the conflict detection and resolution implemented by Server
  Side Apply is that an applier always has up to date field values in their local
  state. If they don’t, they get a conflict the next time they apply. Any of the
  three options to resolve conflicts results in the applied config being an up to
  date subset of the object on the server’s fields.
</p>
<p>
  This is different from Client Side Apply, where outdated values which have been
  overwritten by other users are left in an applier’s local config. These values
  only become accurate when the user updates that specific field, if ever, and an
  applier has no way of knowing whether their next apply will overwrite other
  users’ changes.
</p>
<p>
  Another difference is that an applier using Client Side Apply is unable to
  change the API version they are using, but Server Side Apply supports this use
  case.
</p>
<h3 id="api-endpoint">
  API Endpoint
</h3>
<p>
  With the Server Side Apply feature enabled, the
  <code>
    PATCH
  </code>
  endpoint accepts the
  additional
  <code>
    application/apply-patch+yaml
  </code>
  content type. Users of Server Side
  Apply can send partially specified objects as YAML to this endpoint.
  When applying a configuration, one should always include all the fields
  that they have an opinion about.
</p>
<h3 id="clearing-managedfields">
  Clearing ManagedFields
</h3>
<p>
  It is possible to strip all managedFields from an object by overwriting them
  using
  <code>
    MergePatch
  </code>
  ,
  <code>
    StrategicMergePatch
  </code>
  ,
  <code>
    JSONPatch
  </code>
  or
  <code>
    Update
  </code>
  , so every
  non-apply operation. This can be done by overwriting the managedFields field
  with an empty entry. Two examples are:
</p>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="">PATCH</span> <span style="">/api/v</span><span style="color:#666">1</span><span style="">/namespaces/default/configmaps/example-cm</span>
<span style="">Content-Type:</span> <span style="">application/merge-patch+json</span>
<span style="">Accept:</span> <span style="">application/json</span>
<span style="">Data:</span> {<span style="color:#008000;font-weight:bold">&#34;metadata&#34;</span>:{<span style="color:#008000;font-weight:bold">&#34;managedFields&#34;</span>: [{}]}}</code></pre>
</div>
<div class="highlight">
  <pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="">PATCH</span> <span style="">/api/v</span><span style="color:#666">1</span><span style="">/namespaces/default/configmaps/example-cm</span>
<span style="">Content-Type:</span> <span style="">application/json-patch+json</span>
<span style="">Accept:</span> <span style="">application/json</span>
<span style="">Data:</span> [{<span style="color:#008000;font-weight:bold">&#34;op&#34;</span>: <span style="color:#b44">&#34;replace&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;path&#34;</span>: <span style="color:#b44">&#34;/metadata/managedFields&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;value&#34;</span>: [{}]}]</code></pre>
</div>
<p>
  This will overwrite the managedFields with a list containing a single empty
  entry that then results in the managedFields being stripped entirely from the
  object. Note that just setting the managedFields to an empty list will not reset
  the field. This is on purpose, so managedFields never get stripped by clients
  not aware of the field.
</p>
<p>
  In cases where the reset operation is combined with changes to other fields than
  the managedFields, this will result in the managedFields being reset first and
  the other changes being processed afterwards. As a result the applier takes
  ownership of any fields updated in the same request.
</p>
<blockquote class="caution">
  <div>
    <strong>
      Caution:
    </strong>
    Server Side Apply does not correctly track ownership on
    sub-resources that don’t receive the resource object type. If you are
    using Server Side Apply with such a sub-resource, the changed fields
    won’t be tracked.
  </div>
</blockquote>
<h3 id="disabling-the-feature">
  Disabling the feature
</h3>
<p>
  Server Side Apply is a beta feature, so it is enabled by default. To turn this
  <a href="/docs/reference/command-line-tools-reference/feature-gates">
    feature gate
  </a>
  off,
  you need to include the
  <code>
    --feature-gates ServerSideApply=false
  </code>
  flag when
  starting
  <code>
    kube-apiserver
  </code>
  . If you have multiple
  <code>
    kube-apiserver
  </code>
  replicas, all
  should have the same flag setting.
</p>
<h2 id="resource-versions">
  Resource Versions
</h2>
<p>
  Resource versions are strings that identify the server’s internal version of an object. Resource versions can be used by clients to determine when objects have changed, or to express data consistency requirements when getting, listing and watching resources. Resource versions must be treated as opaque by clients and passed unmodified back to the server. For example, clients must not assume resource versions are numeric, and may only compare two resource version for equality (i.e. must not compare resource versions for greater-than or less-than relationships).
</p>
<h3 id="resourceversion-in-metadata">
  ResourceVersion in metadata
</h3>
<p>
  Clients find resource versions in resources, including the resources in watch events, and list responses returned from the server:
</p>
<p>
  <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#objectmeta-v1-meta">
    v1.meta/ObjectMeta
  </a>
  - The
  <code>
    metadata.resourceVersion
  </code>
  of a resource instance identifies the resource version the instance was last modified at.
</p>
<p>
  <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#listmeta-v1-meta">
    v1.meta/ListMeta
  </a>
  - The
  <code>
    metadata.resourceVersion
  </code>
  of a resource collection (i.e. a list response) identifies the resource version at which the list response was constructed.
</p>
<h3 id="the-resourceversion-parameter">
  The ResourceVersion Parameter
</h3>
<p>
  The get, list and watch operations support the
  <code>
    resourceVersion
  </code>
  parameter.
</p>
<p>
  The exact meaning of this parameter differs depending on the operation and the value of the resource version.
</p>
<p>
  For get and list, the semantics of resource version are:
</p>
<p>
  <strong>
    Get:
  </strong>
</p>
<table>
  <thead>
    <tr>
      <th>
        resourceVersion unset
      </th>
      <th>
        resourceVersion is
        <code>
          0
        </code>
      </th>
      <th>
        resourceVersion is set but not
        <code>
          0
        </code>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        Most Recent
      </td>
      <td>
        Any
      </td>
      <td>
        Not older than
      </td>
    </tr>
  </tbody>
</table>
<p>
  <strong>
    List:
  </strong>
</p>
<table>
  <thead>
    <tr>
      <th>
        paging
      </th>
      <th>
        resourceVersion unset
      </th>
      <th>
        resourceVersion=&#34;0”
      </th>
      <th>
        resourceVersion=”{value other than 0}”
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        limit unset
      </td>
      <td>
        Most Recent
      </td>
      <td>
        Any
      </td>
      <td>
        Not older than
      </td>
    </tr>
    <tr>
      <td>
        limit=&#34;n”, continue unset
      </td>
      <td>
        Most Recent
      </td>
      <td>
        Any
      </td>
      <td>
        Exact
      </td>
    </tr>
    <tr>
      <td>
        limit=&#34;n”, continue=&#34;
        <token>
        ”
      </token></td>
      <td>
        Continue Token, Exact
      </td>
      <td>
        Invalid, but treated as Continue Token, Exact
      </td>
      <td>
        Invalid, HTTP
        <code>
          400 Bad Request
        </code>
      </td>
    </tr>
  </tbody>
</table>
<p>
  The meaning of the get and list semantics are:
</p>
<ul>
  <li>
    <strong>
      Most Recent:
    </strong>
    Return data at the most recent resource version. The returned data must be consistent (i.e. served from etcd via a quorum read).
  </li>
  <li>
    <strong>
      Any:
    </strong>
    Return data at any resource version. The newest available resource version is preferred, but strong consistency is not required; data at any resource version may be served. It is possible for the request to return data at a much older resource version that the client has previously observed, particularly in high availabiliy configurations, due to partitions or stale caches. Clients that cannot tolerate this should not use this semantic.
  </li>
  <li>
    <strong>
      Not older than:
    </strong>
    Return data at least as new as the provided resource version. The newest available data is preferred, but any data not older than this resource version may be served. Note that this ensures only that the objects returned are no older than they were at the time of the provided resource version. The resource version in the
    <code>
      ObjectMeta
    </code>
    of individual object may be older than the provide resource version so long it is for the latest modification to the object at the time of the provided resource version.
  </li>
  <li>
    <strong>
      Exact:
    </strong>
    Return data at the exact resource version provided.
  </li>
  <li>
    <strong>
      Continue Token, Exact:
    </strong>
    Return data at the resource version of the initial paginated list call. The returned Continue Tokens are responsible for keeping track of the initially provided resource version for all paginated list calls after the initial paginated list call.
  </li>
</ul>
<p>
  For watch, the semantics of resource version are:
</p>
<p>
  <strong>
    Watch:
  </strong>
</p>
<table>
  <thead>
    <tr>
      <th>
        resourceVersion unset
      </th>
      <th>
        resourceVersion=&#34;0”
      </th>
      <th>
        resourceVersion=”{value other than 0}”
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        Get State and Start at Most Recent
      </td>
      <td>
        Get State and Start at Any
      </td>
      <td>
        Start at Exact
      </td>
    </tr>
  </tbody>
</table>
<p>
  The meaning of the watch semantics are:
</p>
<ul>
  <li>
    <strong>
      Get State and Start at Most Recent:
    </strong>
    Start a watch at the most recent resource version, which must be consistent (i.e. served from etcd via a quorum read). To establish initial state, the watch begins with synthetic “Added” events of all resources instances that exist at the starting resource version. All following watch events are for all changes that occurred after the resource version the watch started at.
  </li>
  <li>
    <strong>
      Get State and Start at Any:
    </strong>
    Warning: Watches initialize this way may return arbitrarily stale data! Please review this semantic before using it, and favor the other semantics where possible. Start a watch at any resource version, the most recent resource version available is preferred, but not required; any starting resource version is allowed. It is possible for the watch to start at a much older resource version that the client has previously observed, particularly in high availability configurations, due to partitions or stale caches. Clients that cannot tolerate this should not start a watch with this semantic. To establish initial state, the watch begins with synthetic “Added” events for all resources instances that exist at the starting resource version. All following watch events are for all changes that occurred after the resource version the watch started at.
  </li>
  <li>
    <strong>
      Start at Exact:
    </strong>
    Start a watch at an exact resource version. The watch events are for all changes after the provided resource version. Unlike “Get State and Start at Most Recent” and “Get State and Start at Any”, the watch is not started with synthetic “Added” events for the provided resource version. The client is assumed to already have the initial state at the starting resource version since the client provided the resource version.
  </li>
</ul>
<h3 id="410-gone-responses">
  “410 Gone” responses
</h3>
<p>
  Servers are not required to serve all older resource versions and may return a HTTP
  <code>
    410 (Gone)
  </code>
  status code if a client requests a resourceVersion older than the server has retained. Clients must be able to tolerate
  <code>
    410 (Gone)
  </code>
  responses. See
  <a href="#efficient-detection-of-changes">
    Efficient detection of changes
  </a>
  for details on how to handle
  <code>
    410 (Gone)
  </code>
  responses when watching resources.
</p>
<p>
  If you request a a resourceVersion outside the applicable limit then, depending on whether a request is served from cache or not, the API server may reply with a
  <code>
    410 Gone
  </code>
  HTTP response.
</p>
<h3 id="unavailable-resource-versions">
  Unavailable resource versions
</h3>
<p>
  Servers are not required to serve unrecognized resource versions. List and Get requests for unrecognized resource versions may wait briefly for the resource version to become available, should timeout with a
  <code>
    504 (Gateway Timeout)
  </code>
  if the provided resource versions does not become available in a resonable amount of time, and may respond with a
  <code>
    Retry-After
  </code>
  response header indicating how many seconds a client should wait before retrying the request. Currently the kube-apiserver also identifies these responses with a “Too large resource version” message. Watch requests for a unrecognized resource version may wait indefinitely (until the request timeout) for the resource version to become available.
</p></div></div></body></html>